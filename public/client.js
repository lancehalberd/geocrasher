/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./app/advanceGameState.ts":
/*!*********************************!*\
  !*** ./app/advanceGameState.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"advanceGameState\": () => (/* binding */ advanceGameState)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_gems__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/gems */ \"./app/gems.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_monsters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/monsters */ \"./app/monsters.ts\");\n\n\n\n\n\n// Function that is called to advance time in the world.\n// Increments exhaust counter on exhausted tiles\n// Avatar restores % of max health\n// Chance to spawn more coins, monsters, powerups and gems.\n// Eventually: advance timer for resource mining/crafting/training etc.\nfunction advanceGameState(state) {\n    state.saved.radius = (state.saved.radius * 2 + app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.maxRadius) / 3;\n    if (state.saved.avatar.currentHealth < state.avatar.maxHealth && !state.battle.engagedMonster) {\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.regenerateHealth)(state);\n    }\n    const isJourneyMode = state.currentScene === 'journey' || state.currentScene === 'voyage';\n    // Gems do not spawn and tiles do not refresh during journey mode.\n    if (!isJourneyMode) {\n        for (const tile of state.world.activeTiles) {\n            if (tile.exhaustedDuration) {\n                tile.exhaustCounter = (tile.exhaustCounter || 0) + 1;\n                if (tile.exhaustCounter >= tile.exhaustedDuration) {\n                    tile.exhaustedDuration = 0;\n                    (0,app_monsters__WEBPACK_IMPORTED_MODULE_4__.checkToGenerateMonster)(state, tile, .5);\n                }\n            }\n            if (!tile.exhaustedDuration) {\n                (0,app_loot__WEBPACK_IMPORTED_MODULE_3__.checkToGenerateLootForTile)(state, tile);\n                (0,app_monsters__WEBPACK_IMPORTED_MODULE_4__.checkToGenerateMonster)(state, tile, .05);\n            }\n        }\n        (0,app_gems__WEBPACK_IMPORTED_MODULE_2__.checkToSpawnGems)(state);\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/advanceGameState.ts?");

/***/ }),

/***/ "./app/avatar.ts":
/*!***********************!*\
  !*** ./app/avatar.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawAvatar\": () => (/* binding */ drawAvatar),\n/* harmony export */   \"experienceForNextLevel\": () => (/* binding */ experienceForNextLevel),\n/* harmony export */   \"gainExperience\": () => (/* binding */ gainExperience),\n/* harmony export */   \"gainHealth\": () => (/* binding */ gainHealth),\n/* harmony export */   \"getAttackWithoutHealthBonuses\": () => (/* binding */ getAttackWithoutHealthBonuses),\n/* harmony export */   \"getAvatarPosition\": () => (/* binding */ getAvatarPosition),\n/* harmony export */   \"getDefenseWithoutHealthBonuses\": () => (/* binding */ getDefenseWithoutHealthBonuses),\n/* harmony export */   \"getLevelBonus\": () => (/* binding */ getLevelBonus),\n/* harmony export */   \"regenerateHealth\": () => (/* binding */ regenerateHealth),\n/* harmony export */   \"resetLootTotals\": () => (/* binding */ resetLootTotals),\n/* harmony export */   \"updatePlayerStats\": () => (/* binding */ updatePlayerStats)\n/* harmony export */ });\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_utils_skills__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/skills */ \"./app/utils/skills.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\nfunction gainExperience(state, experienceGained) {\n    state.saved.avatar.experience += experienceGained * (1 + (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getSkillValue)(state, 'experiencePower'));\n    const forNextLevel = experienceForNextLevel(state);\n    if (state.saved.avatar.experience >= forNextLevel) {\n        state.saved.avatar.experience -= forNextLevel;\n        // Show the loot total to display level up + stats gained.\n        state.loot.lootCollectedTime = state.time + 5000;\n        resetLootTotals(state);\n        state.saved.avatar.level++;\n        updatePlayerStats(state);\n        state.saved.avatar.currentHealth = state.avatar.maxHealth;\n    }\n}\nfunction resetLootTotals(state) {\n    state.loot.collectionBonus = .9;\n    state.loot.coinsCollected = 0;\n    updatePlayerStats(state);\n    state.loot.initialLevel = state.saved.avatar.level;\n    state.loot.initialSkillPoints = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getTotalSkillPoints)(state);\n    state.loot.initialMaxHealth = state.avatar.maxHealth;\n    state.loot.initialAttack = getAttackWithoutHealthBonuses(state);\n    state.loot.initialDefense = getDefenseWithoutHealthBonuses(state);\n}\nfunction experienceForNextLevel(state) {\n    return Math.round(10 * state.saved.avatar.level * (1.25 ** (state.saved.avatar.level - 1)));\n}\nfunction getLevelBonus(state, level = state.saved.avatar.level) {\n    return 1.08 ** (level - 1);\n}\nfunction updatePlayerStats(state) {\n    const levelBonus = getLevelBonus(state);\n    const { currentHealth, attackBonus, defenseBonus, healthBonus } = state.saved.avatar;\n    state.avatar.maxHealth = Math.round(healthBonus * levelBonus * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getHealthSkillBonus)(state));\n    const baseAttack = attackBonus * levelBonus + (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getSkillValue)(state, 'healthOffense') * currentHealth / 100;\n    state.avatar.attack = Math.round(baseAttack * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getAttackSkillBonus)(state));\n    const missingHealth = state.avatar.maxHealth - currentHealth;\n    const baseDefense = defenseBonus * levelBonus + (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getSkillValue)(state, 'healthDefense') * missingHealth / 100;\n    state.avatar.defense = Math.round(baseDefense * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getDefenseSkillBonus)(state));\n}\nfunction getAvatarPosition(state) {\n    var _a, _b, _c, _d, _e, _f;\n    if (state.dungeon.currentDungeon) {\n        return [\n            (((_c = (_b = (_a = state.dungeon.currentDungeon) === null || _a === void 0 ? void 0 : _a.dungeonPosition) === null || _b === void 0 ? void 0 : _b[0]) !== null && _c !== void 0 ? _c : 0) + .5) * app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.gridLength,\n            (((_f = (_e = (_d = state.dungeon.currentDungeon) === null || _d === void 0 ? void 0 : _d.dungeonPosition) === null || _e === void 0 ? void 0 : _e[1]) !== null && _f !== void 0 ? _f : 0) + .9) * app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.gridLength,\n        ];\n    }\n    return state.world.currentPosition;\n}\nfunction gainHealth(state, amount) {\n    amount *= (1 + (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getSkillValue)(state, 'regeneration'));\n    state.saved.avatar.currentHealth = Math.min(state.avatar.maxHealth, Math.ceil(state.saved.avatar.currentHealth + amount));\n}\n// Regenerate health based on the players current regeneration skill.\nfunction regenerateHealth(state) {\n    const regenerationRate = 0.05;\n    gainHealth(state, Math.ceil(state.avatar.maxHealth * regenerationRate));\n}\nfunction getAttackWithoutHealthBonuses(state) {\n    return Math.round(state.saved.avatar.attackBonus * getLevelBonus(state) * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getAttackSkillBonus)(state));\n}\nfunction getDefenseWithoutHealthBonuses(state) {\n    return Math.round(state.saved.avatar.defenseBonus * getLevelBonus(state) * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_3__.getDefenseSkillBonus)(state));\n}\nfunction drawAvatar(context, state) {\n    const personPosition = getAvatarPosition(state);\n    if (!personPosition)\n        return;\n    // draw current location\n    const point = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_4__.project)(state, personPosition);\n    const scaleToUse = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_4__.getActualScale)(state);\n    let targetSize = Math.round(Math.min(app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.gridLength * scaleToUse * .7, 64));\n    let personDirection = state.globalPosition.direction;\n    if (state.dungeon.currentDungeon) {\n        targetSize = Math.round(app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.gridLength * scaleToUse * 1.2);\n        personDirection = 'down';\n    }\n    const animation = app_images__WEBPACK_IMPORTED_MODULE_2__.avatarAnimations[personDirection];\n    const frame = (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.getFrame)(animation, state.avatar.animationTime);\n    const target = {\n        x: point[0] - Math.round(targetSize / 2),\n        y: point[1] - targetSize,\n        w: targetSize, h: targetSize\n    };\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawFrame)(context, frame, target);\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/avatar.ts?");

/***/ }),

/***/ "./app/battle.ts":
/*!***********************!*\
  !*** ./app/battle.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawDamageIndicators\": () => (/* binding */ drawDamageIndicators),\n/* harmony export */   \"drawFightFleeButton\": () => (/* binding */ drawFightFleeButton),\n/* harmony export */   \"getFightOrFleeButton\": () => (/* binding */ getFightOrFleeButton),\n/* harmony export */   \"updateBattle\": () => (/* binding */ updateBattle)\n/* harmony export */ });\n/* harmony import */ var app_advanceGameState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/advanceGameState */ \"./app/advanceGameState.ts\");\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_utils_skills__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/skills */ \"./app/utils/skills.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\n\n\n\n\n\n\nfunction getAttackTime(level) {\n    return 600 - Math.min(200, (level - 1) * 50);\n}\nfunction getPlayerAttackTime(state) {\n    return getAttackTime(state.saved.avatar.level) / (1 + (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_9__.getSkillValue)(state, 'attackSpeed'));\n}\nfunction updateBattle(state) {\n    var _a, _b;\n    // End battle if the player is too far from the monster marker.\n    const monster = state.battle.engagedMonster;\n    const marker = (_a = state.battle.engagedMonster) === null || _a === void 0 ? void 0 : _a.marker;\n    if (state.battle.damageIndicators.length) {\n        updateDamageIndicators(state);\n    }\n    // End battle if the monster marker is no longer active.\n    if (marker && state.world.activeMonsterMarkers.indexOf(marker) < 0) {\n        delete state.battle.engagedMonster;\n        return;\n    }\n    if (!monster || !marker) {\n        return;\n    }\n    const currentBattlePosition = (_b = (0,app_avatar__WEBPACK_IMPORTED_MODULE_1__.getAvatarPosition)(state)) !== null && _b !== void 0 ? _b : [];\n    if (state.battle.monsterAttackTime && state.time > state.battle.monsterAttackTime) {\n        if (Math.random() < (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_9__.getSkillValue)(state, 'dodge')) {\n            pushDamageIndicator(state, currentBattlePosition, [marker.tile.centerX, marker.tile.centerY], 'Dodge', 'blue');\n        }\n        else {\n            const attackRoll = getAttackRoll(monster.attack);\n            const damage = calculateDamage(attackRoll, getDefenseRoll(state.avatar.defense));\n            pushDamageIndicator(state, currentBattlePosition, [marker.tile.centerX, marker.tile.centerY], (0,app_utils_index__WEBPACK_IMPORTED_MODULE_7__.abbreviateNumber)(damage));\n            state.saved.avatar.currentHealth = Math.max(0, state.saved.avatar.currentHealth - damage);\n            // Blocked damage is difference between the attackRoll and actual damage. Reflected damage is a percentage of this value.\n            const reflectedDamage = Math.ceil((attackRoll - damage) * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_9__.getSkillValue)(state, 'defenseOffense'));\n            if (reflectedDamage) {\n                pushDamageIndicator(state, [marker.tile.centerX, marker.tile.centerY], currentBattlePosition, (0,app_utils_index__WEBPACK_IMPORTED_MODULE_7__.abbreviateNumber)(reflectedDamage), 'orange');\n                monster.currentHealth = Math.max(0, monster.currentHealth - reflectedDamage);\n            }\n            // Boss stats cannot be reduced.\n            if (!monster.isBoss) {\n                monster.attack = Math.max(1, monster.attack - Math.ceil(state.avatar.defense * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_9__.getSkillValue)(state, 'defenseDefense')));\n            }\n        }\n        state.battle.monsterAttackTime += getAttackTime(monster.level);\n    }\n    if (state.battle.playerAttackTime && state.time > state.battle.playerAttackTime) {\n        var damage = calculateDamage(getAttackRoll(state.avatar.attack), getDefenseRoll(monster.defense));\n        pushDamageIndicator(state, [marker.tile.centerX, marker.tile.centerY], currentBattlePosition, (0,app_utils_index__WEBPACK_IMPORTED_MODULE_7__.abbreviateNumber)(damage));\n        monster.currentHealth = Math.max(0, monster.currentHealth - damage);\n        // Boss stats cannot be reduced.\n        if (!monster.isBoss) {\n            monster.defense = Math.max(0, monster.defense - Math.ceil(state.avatar.attack * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_9__.getSkillValue)(state, 'attackOffense')));\n        }\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_1__.gainHealth)(state, damage * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_9__.getSkillValue)(state, 'attackDefense'));\n        state.battle.playerAttackTime += getPlayerAttackTime(state);\n    }\n    if (monster.currentHealth <= 0) {\n        const defeatedMonster = monster;\n        if (!state.dungeon.currentDungeon) {\n            (0,app_advanceGameState__WEBPACK_IMPORTED_MODULE_0__.advanceGameState)(state);\n            (0,app_utils_world__WEBPACK_IMPORTED_MODULE_10__.exhaustTile)(marker.tile);\n        }\n        delete marker.tile.monsterMarker;\n        delete defeatedMonster.marker;\n        // Primarily you are supposed to access dungeons through treasure maps now, but there\n        // is still a 1/50 chance a monster will drop a dungeon entrance.\n        if (Math.random() < 0.02 && !state.dungeon.currentDungeon) {\n            var dungeonLevel = Math.max(1, app_utils_Random__WEBPACK_IMPORTED_MODULE_8__[\"default\"].integerRange(monster.level - 1, monster.level + 1));\n            (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__.addDungeonToTile)(state, marker.tile, dungeonLevel);\n        }\n        else if (Math.random() < .1 && !state.dungeon.currentDungeon) {\n            // 2 at level 1 up to 7 at level 98\n            var value = Math.max(2, Math.floor(Math.sqrt(monster.level / 2)));\n            (0,app_loot__WEBPACK_IMPORTED_MODULE_5__.addLootToTile)(state, marker.tile, (0,app_loot__WEBPACK_IMPORTED_MODULE_5__.makeTreasureMapLoot)(state, value));\n        }\n        const monsterTile = marker.tile;\n        state.world.activeMonsterMarkers.splice(state.world.activeMonsterMarkers.indexOf(marker), 1);\n        const currentLootInMonsterRadius = state.loot.lootInMonsterRadius;\n        delete state.battle.engagedMonster;\n        delete state.selectedTile;\n        // Outside of dungeons, you get nearby treasure for fighting monsters.\n        if (!state.dungeon.currentDungeon) {\n            (0,app_loot__WEBPACK_IMPORTED_MODULE_5__.updateMapLoot)(state);\n            (0,app_avatar__WEBPACK_IMPORTED_MODULE_1__.resetLootTotals)(state);\n            for (const loot of currentLootInMonsterRadius) {\n                if (state.loot.lootInMonsterRadius.indexOf(loot) < 0) {\n                    state.loot.collectingLoot.push(loot);\n                }\n            }\n            if (defeatedMonster.isBoss && state.currentScene === 'journey') {\n                const loot = (defeatedMonster.level >= (1 + state.saved.world.journeySkillPoints) * 3)\n                    ? (0,app_loot__WEBPACK_IMPORTED_MODULE_5__.makeMagicStoneLoot)() : (0,app_loot__WEBPACK_IMPORTED_MODULE_5__.makeTreasureChestLoot)(getCoinRoll(state, defeatedMonster));\n                const x = monsterTile.centerX;\n                const y = monsterTile.centerY;\n                monsterTile.lootMarkers = [{\n                        loot,\n                        x, y, tx: x, ty: y,\n                        tile: monsterTile,\n                    }];\n                state.loot.collectingLoot.push(monsterTile.lootMarkers[0]);\n            }\n        }\n        else {\n            for (const neighbor of (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__.getAllNeighbors)(state, monsterTile)) {\n                neighbor.guards--;\n            }\n            // Bosses only appear in dungeons.\n            // If the current dungeon is a quest dungeon they leave a magic stone behind.\n            // Otherwise they leave a treasure chest behind with a lot of coins.\n            if (defeatedMonster.isBoss) {\n                let loot;\n                if (state.dungeon.currentDungeon.isQuestDungeon) {\n                    loot = (0,app_loot__WEBPACK_IMPORTED_MODULE_5__.makeMagicStoneLoot)();\n                }\n                else {\n                    loot = (0,app_loot__WEBPACK_IMPORTED_MODULE_5__.makeTreasureChestLoot)(getCoinRoll(state, defeatedMonster));\n                }\n                const realCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_10__.toRealCoords)(state, [monsterTile.x, monsterTile.y]);\n                const x = realCoords[0] + app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 2;\n                const y = realCoords[1] + app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 2;\n                monsterTile.lootMarkers = [{\n                        loot,\n                        x, y, tx: x, ty: y,\n                        tile: monsterTile,\n                    }];\n            }\n        }\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_1__.gainExperience)(state, defeatedMonster.experience);\n    }\n    if (state.saved.avatar.currentHealth <= 0) {\n        delete state.battle.engagedMonster;\n        delete state.selectedTile;\n    }\n}\nfunction getCoinRoll(state, monster) {\n    const baseValue = Math.pow(1.1, monster.level) * monster.level * 100;\n    const roll = .9 + Math.random() * .2;\n    return Math.ceil(baseValue * roll * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_9__.getMoneySkillBonus)(state));\n}\nfunction getAttackRoll(attack) {\n    return Math.round((.9 + Math.random() * .2) * attack);\n}\nfunction getDefenseRoll(defense) {\n    return Math.round((.9 + Math.random() * .2) * defense);\n}\nfunction calculateDamage(attackRoll, defenseRoll) {\n    // Damage is 1/n where n = 1 + 2 * (defenseRoll / attackRoll)\n    // 1/2 if defense = 1/2 * attack\n    // 1/3 if defense = attack\n    // 1/5 if defense = 2 * attack\n    // 1/9 if defense = 4 * attack\n    const mitigationFactor = 1 / (1 + 2 * (defenseRoll / attackRoll));\n    return Math.max(1, Math.ceil(attackRoll * mitigationFactor));\n}\nconst fightOrFleeButton = {\n    onClick(state) {\n        var _a;\n        // If not in battle, engage the selected monster in battle:\n        if (!state.battle.engagedMonster) {\n            if (!((_a = state.selectedTile) === null || _a === void 0 ? void 0 : _a.monsterMarker)) {\n                return;\n            }\n            state.battle.engagedMonster = state.selectedTile.monsterMarker.monster;\n            // Monster always attacks first.\n            state.battle.monsterAttackTime = state.time + 300;\n            state.battle.playerAttackTime = state.time + 300 + getPlayerAttackTime(state) / 2;\n        }\n        else {\n            delete state.battle.engagedMonster;\n        }\n    },\n    isDisabled(state) {\n        return state.saved.avatar.currentHealth <= 0;\n    },\n    isVisible(state) {\n        var _a;\n        return !!((_a = state.selectedTile) === null || _a === void 0 ? void 0 : _a.monsterMarker);\n    },\n    render(context, state) {\n        const { iconSize } = state.display;\n        context.textBaseline = 'middle';\n        context.textAlign = 'left';\n        context.font = Math.floor(3 * iconSize / 4) + 'px sans-serif';\n        const text = state.battle.engagedMonster ? 'Flee' : 'Fight';\n        const halfIconSize = Math.floor(iconSize / 2);\n        if (state.battle.engagedMonster) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.shoeSource, { x: this.target.x, y: this.target.y, w: iconSize, h: iconSize });\n        }\n        else {\n            context.save();\n            context.translate(this.target.x + halfIconSize, this.target.y + halfIconSize);\n            context.scale(-1, 1);\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.swordSource, { x: -halfIconSize + 6, y: -halfIconSize, w: iconSize, h: iconSize });\n            context.scale(-1, 1);\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.swordSource, { x: -halfIconSize + 6, y: -halfIconSize, w: iconSize, h: iconSize });\n            context.restore();\n        }\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.drawEmbossedText)(context, text, 'gold', 'black', this.target.x + iconSize, this.target.y + halfIconSize);\n    },\n    updateTarget(state) {\n        const { canvas, iconSize } = state.display;\n        const w = iconSize;\n        // Fight or Flee button is shown in the bottom center of the screen,\n        // just like the collect treasure or upgrade tile button.\n        this.target = {\n            x: Math.floor((canvas.width - w) / 2),\n            y: canvas.height - 10 - iconSize,\n            w,\n            h: iconSize,\n        };\n    },\n    target: { x: 0, y: 0, w: 0, h: 0 }\n};\nfunction getFightOrFleeButton() {\n    return fightOrFleeButton;\n}\nfunction drawFightFleeButton(context, state) {\n    fightOrFleeButton.render(context, state);\n}\nfunction pushDamageIndicator(state, targetPosition, sourcePosition, value, color = 'red') {\n    var dx = targetPosition[0] - sourcePosition[0] + (Math.random() - .5) * app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 5;\n    var dy = targetPosition[1] - sourcePosition[1] + (Math.random() - .5) * app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 5;\n    if (dx == 0 && dy == 0) {\n        dx = Math.random() - .5;\n        dy = Math.random() - .5;\n    }\n    var mag = Math.sqrt(dx * dx + dy * dy);\n    state.battle.damageIndicators.push({ value, color,\n        position: [targetPosition[0], targetPosition[1], app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 10],\n        velocity: [dx / mag * app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 20, dy / mag * app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 20, app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 12],\n    });\n}\nfunction updateDamageIndicators(state) {\n    for (const indicator of state.battle.damageIndicators) {\n        indicator.position[0] += indicator.velocity[0];\n        indicator.position[1] += indicator.velocity[1];\n        indicator.position[2] += indicator.velocity[2];\n        indicator.velocity[2] -= app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 150;\n    }\n    // Remove damage indicators when they hit z <= 0.\n    state.battle.damageIndicators = state.battle.damageIndicators.filter(d => d.position[2] > 0);\n}\nfunction drawDamageIndicators(context, state) {\n    const { iconSize } = state.display;\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    for (const damage of state.battle.damageIndicators) {\n        context.font = Math.round(iconSize / 8 * (1 + 4 * damage.position[2] / app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength)) + 'px sans-serif';\n        var coords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_10__.project)(state, [damage.position[0], damage.position[1] - damage.position[2]]);\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.drawEmbossedText)(context, damage.value, damage.color, 'white', coords[0], coords[1]);\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/battle.ts?");

/***/ }),

/***/ "./app/client.ts":
/*!***********************!*\
  !*** ./app/client.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var app_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/context */ \"./app/context.ts\");\n/* harmony import */ var app_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/dom */ \"./app/dom.ts\");\n/* harmony import */ var app_drawScene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/drawScene */ \"./app/drawScene.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_globalPosition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/globalPosition */ \"./app/globalPosition.ts\");\n/* harmony import */ var app_handleBackAction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/handleBackAction */ \"./app/handleBackAction.ts\");\n/* harmony import */ var app_handleTouchEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/handleTouchEvents */ \"./app/handleTouchEvents.ts\");\n/* harmony import */ var app_mainLoop__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/mainLoop */ \"./app/mainLoop.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n\n\n\n\n\n\n\n\n\nsetTimeout(app_mainLoop__WEBPACK_IMPORTED_MODULE_7__.startMainLoop, 400);\n(0,app_state__WEBPACK_IMPORTED_MODULE_8__.initializeState)();\nlet lastRenderedTime = 0;\nfunction animate() {\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_8__.getState)();\n    window.requestAnimationFrame(animate);\n    if (lastRenderedTime >= state.time) {\n        return;\n    }\n    lastRenderedTime = state.time;\n    (0,app_drawScene__WEBPACK_IMPORTED_MODULE_2__.drawScene)(state.display.context, state);\n}\nanimate();\nfunction resizeCanvas() {\n    app_dom__WEBPACK_IMPORTED_MODULE_1__.mainCanvas.width = window.innerWidth;\n    app_dom__WEBPACK_IMPORTED_MODULE_1__.mainCanvas.height = window.innerHeight;\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_8__.getState)();\n    state.display.iconSize = 16 * Math.floor(Math.min(app_dom__WEBPACK_IMPORTED_MODULE_1__.mainCanvas.width / 6, app_dom__WEBPACK_IMPORTED_MODULE_1__.mainCanvas.height / 6) / 16);\n    state.display.dungeonScale = Math.min((app_dom__WEBPACK_IMPORTED_MODULE_1__.mainCanvas.height - 20) / (5 * app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength), (app_dom__WEBPACK_IMPORTED_MODULE_1__.mainCanvas.width - 20) / (5 * app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength));\n    (0,app_drawScene__WEBPACK_IMPORTED_MODULE_2__.drawScene)(state.display.context, state);\n}\nwindow.onresize = resizeCanvas;\nif (!app_context__WEBPACK_IMPORTED_MODULE_0__.isTestMode) {\n    // Regular play assumes you are walking around playing on a touch device.\n    (0,app_handleTouchEvents__WEBPACK_IMPORTED_MODULE_6__.registerTouchEvents)();\n    if (navigator.geolocation) {\n        (0,app_globalPosition__WEBPACK_IMPORTED_MODULE_4__.checkToWatchPosition)((0,app_state__WEBPACK_IMPORTED_MODULE_8__.getState)());\n    }\n    else {\n        document.body.innerHTML = 'Geolocation is not supported by this browser :(';\n    }\n}\nelse {\n    // Test play allows you to play with a mouse and keyboard.\n    (0,app_handleTouchEvents__WEBPACK_IMPORTED_MODULE_6__.registerMouseEvents)();\n    const stepSize = app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 3;\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_8__.getState)();\n    state.globalPosition.lastPosition = { coords: { longitude: app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 2, latitude: app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 2 } };\n    document.addEventListener('keydown', function (event) {\n        const state = (0,app_state__WEBPACK_IMPORTED_MODULE_8__.getState)();\n        if (!state.globalPosition.lastPosition) {\n            throw new Error('Expeceted `state.globalPosition.lastPosition` to be defined.');\n        }\n        //console.log(event.which)\n        if (event.which === 37 || event.which === 'A'.charCodeAt(0)) {\n            state.globalPosition.lastPosition.coords.longitude -= stepSize;\n        }\n        if (event.which === 39 || event.which === 'D'.charCodeAt(0)) {\n            state.globalPosition.lastPosition.coords.longitude += stepSize;\n        }\n        if (event.which === 38 || event.which === 'W'.charCodeAt(0)) {\n            state.globalPosition.lastPosition.coords.latitude += stepSize;\n        }\n        if (event.which === 40 || event.which === 'S'.charCodeAt(0)) {\n            state.globalPosition.lastPosition.coords.latitude -= stepSize;\n        }\n    });\n}\n(0,app_handleBackAction__WEBPACK_IMPORTED_MODULE_5__.registerBackAction)();\nresizeCanvas();\n\n\n//# sourceURL=webpack://geocrasher/./app/client.ts?");

/***/ }),

/***/ "./app/context.ts":
/*!************************!*\
  !*** ./app/context.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isDebugMode\": () => (/* binding */ isDebugMode),\n/* harmony export */   \"isTestMode\": () => (/* binding */ isTestMode)\n/* harmony export */ });\nconst isTestMode = window.location.search.substr(1).indexOf('test') >= 0;\nconst isDebugMode = window.location.search.substr(1).indexOf('debug') >= 0;\n\n\n//# sourceURL=webpack://geocrasher/./app/context.ts?");

/***/ }),

/***/ "./app/dom.ts":
/*!********************!*\
  !*** ./app/dom.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bodyDiv\": () => (/* binding */ bodyDiv),\n/* harmony export */   \"createCanvas\": () => (/* binding */ createCanvas),\n/* harmony export */   \"createCanvasAndContext\": () => (/* binding */ createCanvasAndContext),\n/* harmony export */   \"debugCanvas\": () => (/* binding */ debugCanvas),\n/* harmony export */   \"divider\": () => (/* binding */ divider),\n/* harmony export */   \"mainCanvas\": () => (/* binding */ mainCanvas),\n/* harmony export */   \"mainContext\": () => (/* binding */ mainContext),\n/* harmony export */   \"query\": () => (/* binding */ query),\n/* harmony export */   \"queryAll\": () => (/* binding */ queryAll),\n/* harmony export */   \"tag\": () => (/* binding */ tag),\n/* harmony export */   \"tagElement\": () => (/* binding */ tagElement),\n/* harmony export */   \"titleDiv\": () => (/* binding */ titleDiv),\n/* harmony export */   \"toggleElement\": () => (/* binding */ toggleElement),\n/* harmony export */   \"toggleElements\": () => (/* binding */ toggleElements)\n/* harmony export */ });\nfunction query(className) {\n    return document.querySelector(className);\n}\nfunction queryAll(className) {\n    return document.querySelectorAll(className);\n}\nconst mainCanvas = query('canvas');\nconst mainContext = mainCanvas.getContext('2d', { alpha: false });\nmainContext.imageSmoothingEnabled = false;\nfunction createCanvas(width, height, classes = '') {\n    const canvas = document.createElement('canvas');\n    canvas.className = classes;\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nfunction createCanvasAndContext(width, height) {\n    const canvas = createCanvas(width, height);\n    const context = canvas.getContext('2d');\n    context.imageSmoothingEnabled = false;\n    return [canvas, context];\n}\nfunction debugCanvas(canvas) {\n    document.body.append(canvas);\n    canvas.style.position = 'absolute';\n    canvas.style.top = '0';\n    canvas.style.left = '0';\n    canvas.style.backgroundColor = 'blue';\n}\n;\nfunction tag(type, classes = '', content = '') {\n    return '<' + type + ' class=\"' + classes + '\">' + content + '</' + type + '>';\n}\nfunction tagElement(type, classes = '', content = '') {\n    const element = document.createElement(type);\n    element.className = classes || '';\n    element.innerHTML = '' + (content || '');\n    return element;\n}\nconst divider = tag('div', 'centered medium', tag('div', 'divider'));\nfunction titleDiv(titleMarkup) {\n    return titleMarkup && tag('div', 'title', titleMarkup);\n}\nfunction bodyDiv(bodyMarkup) {\n    return bodyMarkup && tag('div', 'body', bodyMarkup);\n}\n;\nfunction toggleElements(elements, show) {\n    elements.forEach(element => toggleElement(element, show));\n}\nfunction toggleElement(element, show) {\n    element.style.display = show ? '' : 'none';\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/dom.ts?");

/***/ }),

/***/ "./app/draw.ts":
/*!*********************!*\
  !*** ./app/draw.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawBar\": () => (/* binding */ drawBar),\n/* harmony export */   \"drawEmbossedText\": () => (/* binding */ drawEmbossedText),\n/* harmony export */   \"drawFrame\": () => (/* binding */ drawFrame),\n/* harmony export */   \"drawFrameAt\": () => (/* binding */ drawFrameAt),\n/* harmony export */   \"drawFrameCenteredAt\": () => (/* binding */ drawFrameCenteredAt),\n/* harmony export */   \"drawOutlinedImage\": () => (/* binding */ drawOutlinedImage),\n/* harmony export */   \"drawOutlinedText\": () => (/* binding */ drawOutlinedText),\n/* harmony export */   \"drawRectangle\": () => (/* binding */ drawRectangle),\n/* harmony export */   \"drawRectangleFrame\": () => (/* binding */ drawRectangleFrame),\n/* harmony export */   \"drawSolidTintedImage\": () => (/* binding */ drawSolidTintedImage),\n/* harmony export */   \"drawTintedImage\": () => (/* binding */ drawTintedImage),\n/* harmony export */   \"fillRectangle\": () => (/* binding */ fillRectangle),\n/* harmony export */   \"frame\": () => (/* binding */ frame),\n/* harmony export */   \"frameAnimation\": () => (/* binding */ frameAnimation),\n/* harmony export */   \"framesAnimation\": () => (/* binding */ framesAnimation),\n/* harmony export */   \"getFrame\": () => (/* binding */ getFrame),\n/* harmony export */   \"getFrameHitBox\": () => (/* binding */ getFrameHitBox),\n/* harmony export */   \"getSolidTintedImage\": () => (/* binding */ getSolidTintedImage),\n/* harmony export */   \"getTintedImage\": () => (/* binding */ getTintedImage),\n/* harmony export */   \"logPixel\": () => (/* binding */ logPixel),\n/* harmony export */   \"pad\": () => (/* binding */ pad),\n/* harmony export */   \"prepareTintedImage\": () => (/* binding */ prepareTintedImage)\n/* harmony export */ });\n/* harmony import */ var app_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/dom */ \"./app/dom.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n\n\nfunction frame(x, y, w, h, content) {\n    return { x, y, w, h, content };\n}\n// Make a single frame into an FrameAnimation.\nfunction frameAnimation(frame) {\n    return { frames: [frame], frameDuration: 1, duration: 1 };\n}\nfunction framesAnimation(frames, duration = 8, props = {}) {\n    return { frames, frameDuration: duration, ...props, duration: app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.frameLength * frames.length * duration };\n}\nfunction getFrame(animation, animationTime) {\n    animationTime = Math.max(animationTime, 0);\n    let frameIndex = Math.floor(animationTime / (app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.frameLength * (animation.frameDuration || 1)));\n    if (animation.loop === false) { // You can set this to prevent an animation from looping.\n        frameIndex = Math.min(frameIndex, animation.frames.length - 1);\n    }\n    if (animation.loopFrame && frameIndex >= animation.frames.length) {\n        frameIndex -= animation.loopFrame;\n        frameIndex %= (animation.frames.length - animation.loopFrame);\n        frameIndex += animation.loopFrame;\n    }\n    return animation.frames[frameIndex % animation.frames.length];\n}\n;\nfunction drawFrame(context, { image, x, y, w, h }, { x: tx, y: ty, w: tw, h: th }) {\n    // (x | 0) is faster than Math.floor(x)\n    context.drawImage(image, x | 0, y | 0, w | 0, h | 0, tx | 0, ty | 0, tw | 0, th | 0);\n}\nfunction drawFrameAt(context, { image, content, x, y, w, h }, { x: tx, y: ty, w: tw, h: th }) {\n    var _a, _b;\n    const cw = (_a = content === null || content === void 0 ? void 0 : content.w) !== null && _a !== void 0 ? _a : w;\n    const ch = (_b = content === null || content === void 0 ? void 0 : content.h) !== null && _b !== void 0 ? _b : h;\n    // First set tw/th to the target size of the content of the frame.\n    tw = tw !== null && tw !== void 0 ? tw : cw;\n    th = th !== null && th !== void 0 ? th : ch;\n    const xScale = tw / cw;\n    const yScale = th / ch;\n    // Adjust tx/ty so that x/y will be the top left corner of the content of the frame.\n    tx = tx - ((content === null || content === void 0 ? void 0 : content.x) || 0) * xScale;\n    ty = ty - ((content === null || content === void 0 ? void 0 : content.y) || 0) * yScale;\n    // Before drawing, set tw/th to the target size of the entire frame.\n    tw = xScale * w;\n    th = yScale * h;\n    // (x | 0) is faster than Math.floor(x)\n    context.drawImage(image, x | 0, y | 0, w | 0, h | 0, tx | 0, ty | 0, tw | 0, th | 0);\n}\nfunction drawFrameCenteredAt(context, { image, content, x, y, w, h }, { x: tx, y: ty, w: tw, h: th }) {\n    var _a, _b;\n    const cw = (_a = content === null || content === void 0 ? void 0 : content.w) !== null && _a !== void 0 ? _a : w;\n    const ch = (_b = content === null || content === void 0 ? void 0 : content.h) !== null && _b !== void 0 ? _b : h;\n    // Adjust tx/ty so that x/y will be the top left corner of the content of the frame.\n    tx = tx - ((content === null || content === void 0 ? void 0 : content.x) || 0) + (tw - cw) / 2;\n    ty = ty - ((content === null || content === void 0 ? void 0 : content.y) || 0) + (th - ch) / 2;\n    // (x | 0) is faster than Math.floor(x)\n    context.drawImage(image, x | 0, y | 0, w | 0, h | 0, tx | 0, ty | 0, w | 0, h | 0);\n}\nfunction getFrameHitBox({ content, w, h }, { x, y }) {\n    var _a, _b;\n    return {\n        x, y,\n        w: (_a = content === null || content === void 0 ? void 0 : content.w) !== null && _a !== void 0 ? _a : w,\n        h: (_b = content === null || content === void 0 ? void 0 : content.h) !== null && _b !== void 0 ? _b : h,\n    };\n}\n// Cache of solid tinted images to avoid recreating them each time they are used.\nconst tintedImages = new Map();\nfunction getSolidTintedImage(tint, frame) {\n    var _a;\n    const tintMap = (_a = tintedImages.get(frame.image)) !== null && _a !== void 0 ? _a : {};\n    const key = tint + '-' + [frame.x, frame.y, frame.h, frame.w].join('-');\n    if (tintMap[key]) {\n        return tintMap[key];\n    }\n    tintedImages.set(frame.image, tintMap);\n    // console.log('Creating new tinted image', key, frame.image);\n    const [tintCanvas, tintContext] = (0,app_dom__WEBPACK_IMPORTED_MODULE_0__.createCanvasAndContext)(frame.w, frame.h);\n    const target = { x: 0, y: 0, w: frame.w, h: frame.h };\n    drawNewSolidTintedImage(tintContext, tint, frame, target);\n    const tintedFrame = {\n        image: tintCanvas,\n        ...target,\n    };\n    tintMap[key] = tintedFrame;\n    return tintedFrame;\n}\nfunction drawNewSolidTintedImage(context, tint, frame, target) {\n    // First make a solid color in the shape of the image to tint.\n    globalTintContext.save();\n    globalTintContext.fillStyle = tint;\n    globalTintContext.clearRect(0, 0, frame.w, frame.h);\n    const tintRectangle = { x: 0, y: 0, w: frame.w, h: frame.h };\n    drawFrame(globalTintContext, frame, tintRectangle);\n    globalTintContext.globalCompositeOperation = \"source-in\";\n    globalTintContext.fillRect(0, 0, frame.w, frame.h);\n    drawFrame(context, { image: globalTintCanvas, ...tintRectangle }, target);\n    globalTintContext.restore();\n}\nfunction drawSolidTintedImage(context, tint, frame, target) {\n    const solidFrame = getSolidTintedImage(tint, frame);\n    drawFrame(context, solidFrame, target);\n}\nconst [globalTintCanvas, globalTintContext] = (0,app_dom__WEBPACK_IMPORTED_MODULE_0__.createCanvasAndContext)(150, 300);\nglobalTintContext.imageSmoothingEnabled = false;\nfunction drawTintedImage(context, { color, amount }, frame, target) {\n    // First make a solid color in the shape of the image to tint.\n    const solidFrame = getSolidTintedImage(color, frame);\n    // Next draw the untinted image to the target.\n    drawFrame(context, frame, target);\n    // Finally draw the tint color on y of the target with the desired opacity.\n    const oldAlpha = context.globalAlpha;\n    context.globalAlpha *= amount; // This needs to be multiplicative since we might be drawing a partially transparent image already.\n    drawFrame(context, solidFrame, target);\n    context.globalAlpha = oldAlpha;\n}\nconst [globalCompositeCanvas, globalCompositeContext] = (0,app_dom__WEBPACK_IMPORTED_MODULE_0__.createCanvasAndContext)(150, 150);\nfunction prepareTintedImage() {\n    globalCompositeContext.clearRect(0, 0, globalCompositeCanvas.width, globalCompositeCanvas.height);\n}\nfunction getTintedImage(frame, tint) {\n    const target = { x: 0, y: 0, w: frame.w, h: frame.h };\n    drawTintedImage(globalCompositeContext, tint, frame, target);\n    return { image: globalCompositeCanvas, ...target };\n}\nfunction drawOutlinedImage(context, color, thickness, frame, target) {\n    for (let dy = -1; dy <= 1; dy++) {\n        for (let dx = -1; dx <= 1; dx++) {\n            if ((dy == 0 && dx == 0) || (dx !== 0 && dy !== 0))\n                continue;\n            drawSolidTintedImage(context, color, frame, {\n                ...target,\n                x: target.x + dx * thickness,\n                y: target.y + dy * thickness,\n            });\n        }\n    }\n    drawFrame(context, frame, target);\n}\nfunction logPixel(context, x, y) {\n    console.log(context.getImageData(x, y, 1, 1).data);\n}\nfunction drawBar(context, r, background, color, percent) {\n    percent = Math.max(0, Math.min(1, percent));\n    if (background) {\n        fillRectangle(context, background, r);\n    }\n    const fill = pad(r, 1);\n    fill.w *= percent;\n    fillRectangle(context, color, fill);\n}\nfunction pad({ x, y, w, h }, m) {\n    return { x: x - m, w: w + 2 * m, y: y - m, h: h + 2 * m };\n}\nfunction fillRectangle(context, color, { x, y, w, h }) {\n    context.fillStyle = color;\n    context.fillRect(x, y, w, h);\n}\nfunction drawRectangleFrame(context, color, thickness, { x, y, w, h }) {\n    context.beginPath();\n    context.rect(x, y, w, h);\n    context.rect(x + thickness, y + thickness, w - 2 * thickness, h - 2 * thickness);\n    context.fillStyle = color;\n    context.fill('evenodd');\n}\nfunction drawRectangle(context, { x, y, w, h }) {\n    context.rect(x, y, w, h);\n}\nfunction drawOutlinedText(context, text, textColor, borderColor, thickness, x, y) {\n    context.fillStyle = borderColor;\n    for (let dy = -1; dy <= 1; dy++)\n        for (let dx = -1; dx <= 1; dx++)\n            if (dx !== 0 || dy !== 0)\n                context.fillText(text, x + dx * thickness, y + dy * thickness);\n    context.fillStyle = textColor;\n    context.fillText(text, x, y);\n}\nfunction drawEmbossedText(context, text, colorA, colorB, x, y) {\n    context.fillStyle = colorB;\n    context.fillText(text, x + 1, y + 1);\n    context.fillStyle = colorA;\n    context.fillText(text, x, y);\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/draw.ts?");

/***/ }),

/***/ "./app/drawScene.ts":
/*!**************************!*\
  !*** ./app/drawScene.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawScene\": () => (/* binding */ drawScene)\n/* harmony export */ });\n/* harmony import */ var app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/scenes/dungeonScene */ \"./app/scenes/dungeonScene.ts\");\n/* harmony import */ var app_scenes_mapScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/scenes/mapScene */ \"./app/scenes/mapScene.ts\");\n/* harmony import */ var app_scenes_skillsScene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/scenes/skillsScene */ \"./app/scenes/skillsScene.ts\");\n/* harmony import */ var app_scenes_titleScene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/scenes/titleScene */ \"./app/scenes/titleScene.ts\");\n/* harmony import */ var app_scenes_treasureMapScene__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/scenes/treasureMapScene */ \"./app/scenes/treasureMapScene.ts\");\n\n\n\n\n\nfunction drawScene(context, state) {\n    const { canvas } = state.display;\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    switch (state.currentScene) {\n        case 'loading':\n            drawLoadingScene(context, state);\n            break;\n        case 'title':\n            (0,app_scenes_titleScene__WEBPACK_IMPORTED_MODULE_3__.drawTitleScene)(context, state);\n            break;\n        case 'journey':\n        case 'voyage':\n        case 'map':\n            (0,app_scenes_mapScene__WEBPACK_IMPORTED_MODULE_1__.drawMapScene)(context, state);\n            break;\n        case 'skills':\n            (0,app_scenes_skillsScene__WEBPACK_IMPORTED_MODULE_2__.drawSkillsScene)(context, state);\n            break;\n        case 'dungeon':\n            (0,app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_0__.drawDungeonScene)(context, state);\n            break;\n        case 'treasureMap':\n            (0,app_scenes_treasureMapScene__WEBPACK_IMPORTED_MODULE_4__.drawTreasureMapScene)(context, state);\n            break;\n    }\n}\nfunction drawLoadingScene(context, state) {\n    const { canvas } = state.display;\n    context.fillStyle = 'black';\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    context.fillStyle = 'white';\n    context.font = Math.floor(canvas.width / 10) + 'px sans-serif';\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    context.fillText('LOADING', canvas.width / 2, canvas.height / 2);\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/drawScene.ts?");

/***/ }),

/***/ "./app/fastMode.ts":
/*!*************************!*\
  !*** ./app/fastMode.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"updateFastMode\": () => (/* binding */ updateFastMode)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/context */ \"./app/context.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_gems__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/gems */ \"./app/gems.ts\");\n\n\n\n\nconst maxThreshold = 500;\nfunction updateFastMode(state, millisecondsBetweenUpdates) {\n    if (state.globalPosition.isFixingGPS || app_context__WEBPACK_IMPORTED_MODULE_1__.isTestMode) {\n        return;\n    }\n    if (state.currentScene === 'loading' || state.currentScene === 'title' || state.dungeon.currentDungeon)\n        return;\n    if (!state.globalPosition.isStartingFastMode && !state.globalPosition.isFastMode) {\n        if (millisecondsBetweenUpdates <= maxThreshold) {\n            state.globalPosition.isStartingFastMode = true;\n        }\n        return;\n    }\n    if (state.globalPosition.isStartingFastMode && !state.globalPosition.isFastMode) {\n        if (millisecondsBetweenUpdates > maxThreshold) {\n            state.globalPosition.isStartingFastMode = false;\n            return;\n        }\n        state.globalPosition.isFastMode = true;\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.resetLootTotals)(state);\n        (0,app_gems__WEBPACK_IMPORTED_MODULE_3__.clearAllGems)(state);\n        state.saved.radius = app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.maxRadius;\n        delete state.selectedTile;\n        delete state.battle.engagedMonster;\n        state.globalPosition.endFastModeTime = state.time + 10000;\n        return;\n    }\n    if (millisecondsBetweenUpdates <= maxThreshold) {\n        state.globalPosition.endFastModeTime = state.time + 5000;\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/fastMode.ts?");

/***/ }),

/***/ "./app/gameConstants.ts":
/*!******************************!*\
  !*** ./app/gameConstants.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"emptyJourneyRadius\": () => (/* binding */ emptyJourneyRadius),\n/* harmony export */   \"frameLength\": () => (/* binding */ frameLength),\n/* harmony export */   \"gridLength\": () => (/* binding */ gridLength),\n/* harmony export */   \"maxRadius\": () => (/* binding */ maxRadius),\n/* harmony export */   \"maxScale\": () => (/* binding */ maxScale),\n/* harmony export */   \"maxTileLevel\": () => (/* binding */ maxTileLevel),\n/* harmony export */   \"minRadius\": () => (/* binding */ minRadius),\n/* harmony export */   \"minScale\": () => (/* binding */ minScale),\n/* harmony export */   \"scale\": () => (/* binding */ scale),\n/* harmony export */   \"version\": () => (/* binding */ version)\n/* harmony export */ });\nconst gridLength = 3 / 10000;\nconst minRadius = gridLength / 4;\nconst maxRadius = gridLength * 1.5;\nconst scale = 2.5e5;\nconst maxScale = 5e5;\nconst minScale = 1.5e5;\nconst frameLength = 20;\nconst maxTileLevel = 7;\nconst emptyJourneyRadius = 1.5 * gridLength;\nconst version = '0.0.7';\n\n\n//# sourceURL=webpack://geocrasher/./app/gameConstants.ts?");

/***/ }),

/***/ "./app/gems.ts":
/*!*********************!*\
  !*** ./app/gems.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkToSpawnGems\": () => (/* binding */ checkToSpawnGems),\n/* harmony export */   \"clearAllGems\": () => (/* binding */ clearAllGems),\n/* harmony export */   \"drawGemIndicators\": () => (/* binding */ drawGemIndicators),\n/* harmony export */   \"gemData\": () => (/* binding */ gemData)\n/* harmony export */ });\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\n// How long recent gem pickup locations are excluded from possible gem spawn locations.\nconst historyDuration = 15 * 60 * 1000;\n// The radius around which gems cannot spawn.\nconst exclusionRadius = 6 * app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength;\nconst gemData = [\n    {\n        color: 'orange', frame: app_images__WEBPACK_IMPORTED_MODULE_1__.orangeGemSource, scale: 0.4, spawnRadius: app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength * 6,\n        collectRadius: app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.maxRadius * 1.5, ticks: 4, debuff: .95,\n        tintAmount: .07, tickDuration: 500,\n    },\n    {\n        color: 'green', frame: app_images__WEBPACK_IMPORTED_MODULE_1__.greenGemSource, scale: 0.4, spawnRadius: app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength * 10,\n        collectRadius: app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.maxRadius * 2, ticks: 8, debuff: .95,\n        tintAmount: .04, tickDuration: 300,\n    },\n    {\n        color: 'blue', frame: app_images__WEBPACK_IMPORTED_MODULE_1__.blueGemSource, scale: 0.4, spawnRadius: app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength * 14,\n        collectRadius: app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.maxRadius * 3, ticks: 16, debuff: .95,\n        tintAmount: .03, tickDuration: 200,\n    },\n];\nclass GemLootClass {\n    constructor(color) {\n        this.type = 'gem';\n        this.scale = 1;\n        this.color = color;\n        this.gem = gemData.find(gem => gem.color === this.color);\n        this.frame = this.gem.frame;\n        this.scale = this.gem.scale;\n    }\n    onObtain(state) {\n        const [x, y] = state.world.currentPosition;\n        state.saved.gems.recentLocations.push({\n            x,\n            y,\n            time: state.time,\n        });\n        if (state.saved.gems.recentLocations.length > 3) {\n            state.saved.gems.recentLocations.shift();\n        }\n        const radiusSquared = this.gem.collectRadius * this.gem.collectRadius;\n        // We don't need to restart bonus counter because it is already counting for this pickup.\n        for (const tileData of state.world.activeTiles) {\n            for (const lootMarker of tileData.lootMarkers) {\n                // ignore loot already being collected.\n                if (state.loot.collectingLoot.indexOf(lootMarker) >= 0) {\n                    continue;\n                }\n                const dx = x - lootMarker.x, dy = y - lootMarker.y;\n                // We go ahead and allow claiming monster loot this way.\n                if (dx * dx + dy * dy <= radiusSquared) {\n                    state.loot.collectingLoot.push(lootMarker);\n                }\n            }\n        }\n        state.gems.colorCounters[this.gem.color] = this.gem.ticks;\n    }\n}\nfunction checkToSpawnGems(state) {\n    if (state.globalPosition.isFastMode\n        || state.globalPosition.isFixingGPS\n        || !state.world.currentPosition\n        || state.currentScene !== 'map') {\n        return;\n    }\n    const { gemMarkers } = state.gems;\n    for (const gem of gemData) {\n        const currentGemMarker = gemMarkers.find(gemMarker => gemMarker.loot.color === gem.color);\n        if (currentGemMarker) {\n            if ((0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.getDistance)([currentGemMarker.x, currentGemMarker.y], state.world.currentPosition) < gem.spawnRadius + app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength * 5) {\n                continue;\n            }\n            // Remove the current gem marker if it is too far from the avatar's current location.\n            gemMarkers.splice(gemMarkers.indexOf(currentGemMarker));\n        }\n        const theta = Math.random() * 2 * Math.PI;\n        let bestTile = null;\n        for (let dt = 0; dt < 2 * Math.PI; dt += Math.PI / 20) {\n            const coords = [\n                state.world.currentPosition[0] + Math.cos(theta + dt) * gem.spawnRadius,\n                state.world.currentPosition[1] + Math.sin(theta + dt) * gem.spawnRadius,\n            ];\n            const gridCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_4__.toGridCoords)(state, coords);\n            const tile = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_4__.getTileData)(state, gridCoords);\n            if (!tile || areCoordsInGemHistory(state, coords)) {\n                continue;\n            }\n            if (!bestTile || tile.level > bestTile.level) {\n                bestTile = tile;\n            }\n        }\n        if (bestTile) {\n            bestTile.gemMarker = (0,app_loot__WEBPACK_IMPORTED_MODULE_2__.addLootToTile)(state, bestTile, new GemLootClass(gem.color));\n            gemMarkers.push(bestTile.gemMarker);\n        }\n    }\n}\nfunction clearAllGems(state) {\n    for (const gemMarker of state.gems.gemMarkers) {\n        const mapTile = gemMarker.tile;\n        mapTile.lootMarkers.splice(mapTile.lootMarkers.indexOf(gemMarker), 1);\n        delete mapTile.gemMarker;\n    }\n}\nfunction areCoordsInGemHistory(state, coords) {\n    for (let i = 0; i < state.saved.gems.recentLocations.length; i++) {\n        const recentLocation = state.saved.gems.recentLocations[i];\n        if (state.time - recentLocation.time >= historyDuration) {\n            state.saved.gems.recentLocations.splice(i--, 1);\n            continue;\n        }\n        if ((0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.getDistance)(coords, [recentLocation.x, recentLocation.y]) < exclusionRadius) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction drawGemIndicators(context, state) {\n    const { canvas } = state.display;\n    const scaleToUse = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_4__.getActualScale)(state);\n    const { currentPosition } = state.world;\n    if (!currentPosition) {\n        return;\n    }\n    const playerScreenCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_4__.project)(state, currentPosition);\n    // Draw effects for any gem being collected.\n    for (const gem of gemData) {\n        const currentTick = state.gems.colorCounters[gem.color] || 0;\n        if (state.gems.nextTickTime && currentTick) {\n            const percent = currentTick / gem.ticks;\n            context.save();\n            context.globalAlpha = (percent >= 1) ? .3 : .2 + .3 * (state.gems.nextTickTime - state.time) / gem.tickDuration;\n            context.fillStyle = gem.color;\n            context.beginPath();\n            if (percent < 1) {\n                context.moveTo(playerScreenCoords[0], playerScreenCoords[1]);\n            }\n            context.arc(playerScreenCoords[0], playerScreenCoords[1], gem.collectRadius * scaleToUse, -Math.PI / 2 - percent * 2 * Math.PI, -Math.PI / 2);\n            if (percent < 1) {\n                context.closePath();\n            }\n            context.fill();\n            context.restore();\n        }\n    }\n    // Gems are only collectible in the map scene, so don't draw indicators for them\n    // in other scenes (journey/voyage mode specifically).\n    if (state.currentScene !== 'map') {\n        return;\n    }\n    for (const gemMarker of state.gems.gemMarkers) {\n        if (state.loot.collectingLoot.indexOf(gemMarker) >= 0)\n            continue;\n        const distance = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.getDistance)([gemMarker.x, gemMarker.y], currentPosition);\n        const pixelDistance = distance * scaleToUse;\n        let indicatorScreenCoords;\n        let distanceFactor = (pixelDistance - 40) / pixelDistance;\n        const dx = (gemMarker.x - currentPosition[0]);\n        const dy = (gemMarker.y - currentPosition[1]);\n        //console.log(distanceFactor);\n        if (currentPosition[0] < gemMarker.x) {\n            distanceFactor = Math.min(distanceFactor, (canvas.width - playerScreenCoords[0] - 20) / (dx * scaleToUse));\n        }\n        if (currentPosition[0] > gemMarker.x) {\n            distanceFactor = Math.min(distanceFactor, (playerScreenCoords[0] - 20) / (-dx * scaleToUse));\n        }\n        if (currentPosition[1] < gemMarker.y) {\n            distanceFactor = Math.min(distanceFactor, (canvas.height - playerScreenCoords[1] - 20) / (dy * scaleToUse));\n        }\n        if (currentPosition[1] > gemMarker.y) {\n            distanceFactor = Math.min(distanceFactor, (playerScreenCoords[1] - 20) / (-dy * scaleToUse));\n        }\n        //console.log([pixelDistance, distanceFactor]);\n        indicatorScreenCoords = [\n            distanceFactor * dx * scaleToUse + playerScreenCoords[0],\n            distanceFactor * dy * scaleToUse + playerScreenCoords[1]\n        ];\n        context.lineWidth = 1;\n        context.fillStyle = gemMarker.loot.color;\n        context.strokeStyle = 'white';\n        const normal = [dx / distance, dy / distance];\n        context.beginPath();\n        context.moveTo(indicatorScreenCoords[0], indicatorScreenCoords[1]);\n        context.lineTo(indicatorScreenCoords[0] - 8 * normal[0] + 20 * normal[1], indicatorScreenCoords[1] - 8 * normal[1] - 20 * normal[0]);\n        context.lineTo(indicatorScreenCoords[0] - 8 * normal[0] - 20 * normal[1], indicatorScreenCoords[1] - 8 * normal[1] + 20 * normal[0]);\n        context.closePath();\n        context.fill();\n        context.stroke();\n        if (distance >= 10 * app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength) {\n            context.beginPath();\n            context.moveTo(indicatorScreenCoords[0] - 15 * normal[0], indicatorScreenCoords[1] - 15 * normal[1]);\n            context.lineTo(indicatorScreenCoords[0] - 20 * normal[0] + 18 * normal[1], indicatorScreenCoords[1] - 20 * normal[1] - 18 * normal[0]);\n            context.lineTo(indicatorScreenCoords[0] - 20 * normal[0] - 18 * normal[1], indicatorScreenCoords[1] - 20 * normal[1] + 18 * normal[0]);\n            context.closePath();\n            context.fill();\n            context.stroke();\n        }\n        if (distance >= 15 * app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength) {\n            context.beginPath();\n            context.moveTo(indicatorScreenCoords[0] - 27 * normal[0], indicatorScreenCoords[1] - 27 * normal[1]);\n            context.lineTo(indicatorScreenCoords[0] - 30 * normal[0] + 15 * normal[1], indicatorScreenCoords[1] - 30 * normal[1] - 15 * normal[0]);\n            context.lineTo(indicatorScreenCoords[0] - 30 * normal[0] - 15 * normal[1], indicatorScreenCoords[1] - 30 * normal[1] + 15 * normal[0]);\n            context.closePath();\n            context.fill();\n            context.stroke();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/gems.ts?");

/***/ }),

/***/ "./app/globalPosition.ts":
/*!*******************************!*\
  !*** ./app/globalPosition.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkToWatchPosition\": () => (/* binding */ checkToWatchPosition)\n/* harmony export */ });\n/* harmony import */ var app_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/context */ \"./app/context.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_gems__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/gems */ \"./app/gems.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n\n\n\n\n\nconst updatePosition = (position) => {\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_3__.getState)();\n    // After receiving a position update, we will attempt to restart the position listener\n    // if 2 seconds pass without an update.\n    state.globalPosition.restartWatchTime = state.time + 2000;\n    if (state.globalPosition.lastPosition) {\n        const oldCoords = [state.globalPosition.lastPosition.coords.longitude, state.globalPosition.lastPosition.coords.latitude];\n        const newCoords = [position.coords.longitude, position.coords.latitude];\n        // If the user ever moves an entire grid length in one click we assume the GPS is unreliable\n        // and enter 'fixing GPS' mode to wait for a more reliable pattern.\n        if ((0,app_utils_index__WEBPACK_IMPORTED_MODULE_4__.getDistance)(oldCoords, newCoords) > app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.gridLength) {\n            setFixingGPS(state);\n        }\n    }\n    state.globalPosition.lastPosition = position;\n};\nfunction setFixingGPS(state) {\n    state.globalPosition.isFixingGPS = true;\n    state.globalPosition.isFastMode = false;\n    state.globalPosition.isStartingFastMode = false;\n    state.globalPosition.endFixingGPSTime = state.time + 2000;\n    (0,app_gems__WEBPACK_IMPORTED_MODULE_2__.clearAllGems)(state);\n}\nlet watchPositionId;\nfunction checkToWatchPosition(state) {\n    if (!navigator.geolocation || app_context__WEBPACK_IMPORTED_MODULE_0__.isTestMode) {\n        return;\n    }\n    if (state.time < state.globalPosition.restartWatchTime) {\n        return;\n    }\n    // When we initially start listening for position updates, we wait 5 seconds without getting any updates\n    // before we try to restart the position listener.\n    state.globalPosition.restartWatchTime = state.time + 5000;\n    // Clear previous listener, if any.\n    if (watchPositionId)\n        navigator.geolocation.clearWatch(watchPositionId);\n    watchPositionId = navigator.geolocation.watchPosition(updatePosition, () => {\n        // document.body.innerHTML = '<div style=\"color: white;\">There was an error getting position!</div>';\n    }, { enableHighAccuracy: true, maximumAge: 100, timeout: 50000 });\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/globalPosition.ts?");

/***/ }),

/***/ "./app/handleBackAction.ts":
/*!*********************************!*\
  !*** ./app/handleBackAction.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"exitDungeon\": () => (/* binding */ exitDungeon),\n/* harmony export */   \"hideTreasureMap\": () => (/* binding */ hideTreasureMap),\n/* harmony export */   \"registerBackAction\": () => (/* binding */ registerBackAction),\n/* harmony export */   \"triggerBackAction\": () => (/* binding */ triggerBackAction)\n/* harmony export */ });\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_utils_refreshActiveTiles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/refreshActiveTiles */ \"./app/utils/refreshActiveTiles.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n\n\n\nfunction hideTreasureMap(state) {\n    delete state.selectedTile;\n    state.world.origin = state.world.currentPosition;\n    (0,app_state__WEBPACK_IMPORTED_MODULE_2__.popScene)(state);\n    (0,app_utils_refreshActiveTiles__WEBPACK_IMPORTED_MODULE_1__.refreshActiveTiles)(state);\n}\nfunction exitDungeon(state) {\n    state.world.origin = state.world.currentPosition;\n    delete state.battle.engagedMonster;\n    delete state.selectedTile;\n    delete state.dungeon.currentDungeon;\n    (0,app_state__WEBPACK_IMPORTED_MODULE_2__.popScene)(state);\n    (0,app_utils_refreshActiveTiles__WEBPACK_IMPORTED_MODULE_1__.refreshActiveTiles)(state);\n}\nfunction handlePopState(event) {\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_2__.getState)();\n    const { currentScene, sceneStack } = state;\n    if (sceneStack.length) {\n        if (currentScene === 'skills') {\n            state.currentScene = sceneStack.pop();\n        }\n        else if (currentScene === 'treasureMap') {\n            hideTreasureMap(state);\n        }\n        else if (currentScene === 'map') {\n            if (confirm('Are you sure you want to quit and return to the main menu?')) {\n                (0,app_saveGame__WEBPACK_IMPORTED_MODULE_0__.saveGame)(state);\n                state.currentScene = sceneStack.pop();\n            }\n            else {\n                history.pushState({}, '');\n            }\n        }\n        else if (state.dungeon.currentDungeon) {\n            if (confirm('Are you sure you want to exit the dungeon?')) {\n                exitDungeon(state);\n            }\n            else {\n                history.pushState({}, '');\n            }\n        }\n    }\n}\nfunction registerBackAction() {\n    window.addEventListener('popstate', handlePopState);\n}\nfunction triggerBackAction() {\n    window.history.back();\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/handleBackAction.ts?");

/***/ }),

/***/ "./app/handleTouchEvents.ts":
/*!**********************************!*\
  !*** ./app/handleTouchEvents.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"registerMouseEvents\": () => (/* binding */ registerMouseEvents),\n/* harmony export */   \"registerTouchEvents\": () => (/* binding */ registerTouchEvents)\n/* harmony export */ });\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/scenes/dungeonScene */ \"./app/scenes/dungeonScene.ts\");\n/* harmony import */ var app_scenes_mapScene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/scenes/mapScene */ \"./app/scenes/mapScene.ts\");\n/* harmony import */ var app_scenes_skillsScene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/scenes/skillsScene */ \"./app/scenes/skillsScene.ts\");\n/* harmony import */ var app_scenes_titleScene__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/scenes/titleScene */ \"./app/scenes/titleScene.ts\");\n/* harmony import */ var app_scenes_treasureMapScene__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/scenes/treasureMapScene */ \"./app/scenes/treasureMapScene.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\n\n\n\nconst mouseMoveThreshold = 5;\nconst touchMoveThreshold = 5;\nlet lastTouchEvent, firstTouchEvent;\nlet lastMouseEvent, mouseDownEvent;\nlet touchMoved = false, mouseMoved = false;\nfunction handleTouchStart(event) {\n    event.preventDefault();\n    lastTouchEvent = event;\n    firstTouchEvent = event;\n    touchMoved = false;\n}\nfunction handleTouchMove(event) {\n    event.preventDefault();\n    if (!lastTouchEvent || !firstTouchEvent) {\n        return;\n    }\n    if (Math.abs(firstTouchEvent.touches[0].pageX - event.touches[0].pageX) > touchMoveThreshold\n        || Math.abs(firstTouchEvent.touches[0].pageY - event.touches[0].pageY) > touchMoveThreshold) {\n        touchMoved = true;\n    }\n    // Dragging is only supported in the map scene currently.\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_6__.getState)();\n    if (state.currentScene !== 'map') {\n        return;\n    }\n    if (lastTouchEvent.touches.length === 1 && event.touches.length === 1) {\n        const dx = event.touches[0].pageX - lastTouchEvent.touches[0].pageX;\n        const dy = event.touches[0].pageY - lastTouchEvent.touches[0].pageY;\n        if (state.world.origin) {\n            state.world.origin[0] -= dx / (0,app_utils_world__WEBPACK_IMPORTED_MODULE_7__.getActualScale)(state);\n            state.world.origin[1] -= dy / (0,app_utils_world__WEBPACK_IMPORTED_MODULE_7__.getActualScale)(state);\n        }\n        lastTouchEvent = event;\n        if (!state.battle.engagedMonster) {\n            delete state.selectedTile;\n        }\n        return;\n    }\n    //if (isDebugMode) alert([lastTouchEvent.touches.length,event.touches.length]);\n    if (lastTouchEvent.touches.length === 2 && event.touches.length === 2) {\n        let touchScale = getTouchEventDistance(event) / getTouchEventDistance(lastTouchEvent);\n        //if (isDebugMode) alert([getTouchEventDistance(event), getTouchEventDistance(lastTouchEvent)]);\n        touchScale = Math.max(.8, Math.min(1.2, isNaN(touchScale) ? 1 : touchScale));\n        state.world.displayScale = Math.min(app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.maxScale, Math.max(app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.minScale, state.world.displayScale * touchScale));\n        lastTouchEvent = event;\n        return;\n    }\n}\nfunction handleTouchEnd(event) {\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_6__.getState)();\n    event.preventDefault();\n    /*if (isDebugMode) {\n        alert('end');\n        alert(touchMoved);\n        alert(lastTouchEvent.touches.length);\n        alert(firstTouchEvent.touches.length);\n    }*/\n    if (!touchMoved && (lastTouchEvent === null || lastTouchEvent === void 0 ? void 0 : lastTouchEvent.touches.length) === 1 && (firstTouchEvent === null || firstTouchEvent === void 0 ? void 0 : firstTouchEvent.touches.length) === 1) {\n        //if (isDebugMode) alert([lastTouchEvent.touches[0].pageX , lastTouchEvent.touches[0].pageY]);\n        //if (isDebugMode) alert([$(this).offset().left , $(this).offset().top]);\n        const x = lastTouchEvent.touches[0].pageX;\n        const y = lastTouchEvent.touches[0].pageY;\n        handleClick(state, x, y);\n        //if (isDebugMode) alert([x, y]);\n    }\n    lastTouchEvent = null;\n    firstTouchEvent = null;\n    touchMoved = false;\n}\nfunction handleClick(state, x, y) {\n    switch (state.currentScene) {\n        case 'title':\n            (0,app_scenes_titleScene__WEBPACK_IMPORTED_MODULE_4__.handleTitleClick)(state, x, y);\n            break;\n        case 'journey':\n        case 'map':\n        case 'voyage':\n            (0,app_scenes_mapScene__WEBPACK_IMPORTED_MODULE_2__.handleMapClick)(state, x, y);\n            break;\n        case 'dungeon':\n            (0,app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_1__.handleDungeonClick)(state, x, y);\n            break;\n        case 'treasureMap':\n            (0,app_scenes_treasureMapScene__WEBPACK_IMPORTED_MODULE_5__.handleTreasureMapClick)(state, x, y);\n            break;\n        case 'skills':\n            (0,app_scenes_skillsScene__WEBPACK_IMPORTED_MODULE_3__.handleSkillsClick)(state, x, y);\n            break;\n    }\n}\nfunction handleMouseDown(event) {\n    mouseDownEvent = lastMouseEvent = event;\n    mouseMoved = false;\n}\nfunction handleMouseMove(event) {\n    if (!lastMouseEvent || !mouseDownEvent) {\n        return;\n    }\n    if (Math.abs(event.pageX - mouseDownEvent.pageX) > mouseMoveThreshold\n        || Math.abs(event.pageY - mouseDownEvent.pageY) > mouseMoveThreshold) {\n        mouseMoved = true;\n    }\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_6__.getState)();\n    // Dragging is only supported in the map scene currently.\n    if (state.currentScene !== 'map') {\n        return;\n    }\n    const dx = event.pageX - lastMouseEvent.pageX;\n    const dy = event.pageY - lastMouseEvent.pageY;\n    if (state.world.origin) {\n        state.world.origin[0] -= dx / (0,app_utils_world__WEBPACK_IMPORTED_MODULE_7__.getActualScale)(state);\n        state.world.origin[1] -= dy / (0,app_utils_world__WEBPACK_IMPORTED_MODULE_7__.getActualScale)(state);\n    }\n    lastMouseEvent = event;\n}\nfunction handleMouseUp(event) {\n    const state = (0,app_state__WEBPACK_IMPORTED_MODULE_6__.getState)();\n    if (!mouseMoved) {\n        const x = event.pageX;\n        const y = event.pageY;\n        handleClick(state, x, y);\n    }\n    lastMouseEvent = null;\n    mouseMoved = false;\n}\nfunction registerTouchEvents() {\n    document.addEventListener('touchstart', handleTouchStart);\n    document.addEventListener('touchmove', handleTouchMove);\n    document.addEventListener('touchend', handleTouchEnd);\n}\nfunction registerMouseEvents() {\n    document.addEventListener('mousedown', handleMouseDown);\n    document.addEventListener('mousemove', handleMouseMove);\n    document.addEventListener('mouseup', handleMouseUp);\n    document.addEventListener('wheel', (event) => {\n        const state = (0,app_state__WEBPACK_IMPORTED_MODULE_6__.getState)();\n        const scrollScale = Math.pow(0.99, event.deltaY);\n        state.world.displayScale = Math.min(app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.maxScale, Math.max(app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.minScale, state.world.displayScale * scrollScale));\n    });\n}\nfunction getTouchEventDistance(touchEvent) {\n    const dx = touchEvent.touches[0].pageX - touchEvent.touches[1].pageX;\n    const dy = touchEvent.touches[0].pageY - touchEvent.touches[1].pageY;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/handleTouchEvents.ts?");

/***/ }),

/***/ "./app/hud.ts":
/*!********************!*\
  !*** ./app/hud.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"handleHudButtonClick\": () => (/* binding */ handleHudButtonClick),\n/* harmony export */   \"renderHudButtons\": () => (/* binding */ renderHudButtons)\n/* harmony export */ });\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n\nfunction renderHudButtons(context, state, buttons) {\n    var _a;\n    for (const button of buttons) {\n        if (((_a = button.isVisible) === null || _a === void 0 ? void 0 : _a.call(button, state)) === false) {\n            continue;\n        }\n        button.render(context, state);\n    }\n}\nfunction handleHudButtonClick(state, x, y, buttons) {\n    var _a, _b;\n    // The buttons are considered in reverse order so that buttons drawn on top have highest priority.\n    for (const button of [...buttons].reverse()) {\n        if (((_a = button.isVisible) === null || _a === void 0 ? void 0 : _a.call(button, state)) === false) {\n            continue;\n        }\n        if ((0,app_utils_index__WEBPACK_IMPORTED_MODULE_0__.isPointInRectangle)(x, y, button.target)) {\n            if (((_b = button.isDisabled) === null || _b === void 0 ? void 0 : _b.call(button, state)) !== true) {\n                button.onClick(state, x, y);\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/hud.ts?");

/***/ }),

/***/ "./app/images.ts":
/*!***********************!*\
  !*** ./app/images.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"avatarAnimations\": () => (/* binding */ avatarAnimations),\n/* harmony export */   \"avatarDimensions\": () => (/* binding */ avatarDimensions),\n/* harmony export */   \"blueGemSource\": () => (/* binding */ blueGemSource),\n/* harmony export */   \"bugSource\": () => (/* binding */ bugSource),\n/* harmony export */   \"chestSource\": () => (/* binding */ chestSource),\n/* harmony export */   \"clockSource\": () => (/* binding */ clockSource),\n/* harmony export */   \"coinImage\": () => (/* binding */ coinImage),\n/* harmony export */   \"crabSource\": () => (/* binding */ crabSource),\n/* harmony export */   \"createAnimation\": () => (/* binding */ createAnimation),\n/* harmony export */   \"darkStoneImage\": () => (/* binding */ darkStoneImage),\n/* harmony export */   \"dirtSource\": () => (/* binding */ dirtSource),\n/* harmony export */   \"exitSource\": () => (/* binding */ exitSource),\n/* harmony export */   \"finishedLoadingImages\": () => (/* binding */ finishedLoadingImages),\n/* harmony export */   \"forestSource\": () => (/* binding */ forestSource),\n/* harmony export */   \"fungusSource\": () => (/* binding */ fungusSource),\n/* harmony export */   \"grassSource\": () => (/* binding */ grassSource),\n/* harmony export */   \"greenGemSource\": () => (/* binding */ greenGemSource),\n/* harmony export */   \"heartSource\": () => (/* binding */ heartSource),\n/* harmony export */   \"hillSource\": () => (/* binding */ hillSource),\n/* harmony export */   \"iceSource\": () => (/* binding */ iceSource),\n/* harmony export */   \"magicStoneSource\": () => (/* binding */ magicStoneSource),\n/* harmony export */   \"moneySource\": () => (/* binding */ moneySource),\n/* harmony export */   \"mountainSource\": () => (/* binding */ mountainSource),\n/* harmony export */   \"oceanImage\": () => (/* binding */ oceanImage),\n/* harmony export */   \"oceanSource\": () => (/* binding */ oceanSource),\n/* harmony export */   \"oceanTile\": () => (/* binding */ oceanTile),\n/* harmony export */   \"oceanTileContext\": () => (/* binding */ oceanTileContext),\n/* harmony export */   \"oldMapImage\": () => (/* binding */ oldMapImage),\n/* harmony export */   \"orangeGemSource\": () => (/* binding */ orangeGemSource),\n/* harmony export */   \"outlinedMoneyContext\": () => (/* binding */ outlinedMoneyContext),\n/* harmony export */   \"outlinedMoneyImage\": () => (/* binding */ outlinedMoneyImage),\n/* harmony export */   \"outlinedMoneySource\": () => (/* binding */ outlinedMoneySource),\n/* harmony export */   \"outlinedPersonContext\": () => (/* binding */ outlinedPersonContext),\n/* harmony export */   \"outlinedPersonImage\": () => (/* binding */ outlinedPersonImage),\n/* harmony export */   \"personSource\": () => (/* binding */ personSource),\n/* harmony export */   \"portalSource\": () => (/* binding */ portalSource),\n/* harmony export */   \"requireFrame\": () => (/* binding */ requireFrame),\n/* harmony export */   \"requireImage\": () => (/* binding */ requireImage),\n/* harmony export */   \"sandSource\": () => (/* binding */ sandSource),\n/* harmony export */   \"scrollSource\": () => (/* binding */ scrollSource),\n/* harmony export */   \"shallowSource\": () => (/* binding */ shallowSource),\n/* harmony export */   \"shellSource\": () => (/* binding */ shellSource),\n/* harmony export */   \"shieldSource\": () => (/* binding */ shieldSource),\n/* harmony export */   \"shoeSource\": () => (/* binding */ shoeSource),\n/* harmony export */   \"snailSource\": () => (/* binding */ snailSource),\n/* harmony export */   \"swordSource\": () => (/* binding */ swordSource),\n/* harmony export */   \"trashSource\": () => (/* binding */ trashSource),\n/* harmony export */   \"treasureMapSource\": () => (/* binding */ treasureMapSource),\n/* harmony export */   \"turtleSource\": () => (/* binding */ turtleSource),\n/* harmony export */   \"upArrows\": () => (/* binding */ upArrows),\n/* harmony export */   \"walkFrames\": () => (/* binding */ walkFrames),\n/* harmony export */   \"waspSource\": () => (/* binding */ waspSource)\n/* harmony export */ });\n/* harmony import */ var app_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/dom */ \"./app/dom.ts\");\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n\n\n\nconst assetVersion = '1';\nconst images = {};\nfunction loadImage(source, callback) {\n    images[source] = new Image();\n    images[source].onload = () => callback();\n    images[source].src = source + '?v=' + assetVersion;\n    return images[source];\n}\nfunction createAnimation(source, dimensions, { x = 0, y = 0, rows = 1, cols = 1, xSpace = 0, top = 0, left = 0, duration = 8, frameMap } = {}, props = {}) {\n    let frames = [];\n    let image;\n    if (typeof source === 'string') {\n        image = requireImage(source);\n    }\n    else {\n        image = source;\n    }\n    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n            frames[row * cols + col] = {\n                ...dimensions,\n                x: left + (dimensions.w + xSpace) * (x + col),\n                y: top + dimensions.h * (y + row),\n                image\n            };\n        }\n    }\n    // Say an animation has 3 frames, but you want to order them 0, 1, 2, 1, then pass frameMap = [0, 1, 2, 1],\n    // to remap the order of the frames accordingly.\n    if (frameMap) {\n        frames = frameMap.map(originalIndex => frames[originalIndex]);\n    }\n    return { frames, frameDuration: duration, ...props, duration: app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.frameLength * frames.length * duration };\n}\n;\nlet numberOfImagesLeftToLoad = 0;\nfunction requireImage(imageFile, callback) {\n    if (images[imageFile]) {\n        // Make sure this callback runs after the return value gets set.\n        setTimeout(() => callback === null || callback === void 0 ? void 0 : callback(images[imageFile]), 1);\n        return images[imageFile];\n    }\n    numberOfImagesLeftToLoad++;\n    return loadImage(imageFile, () => {\n        numberOfImagesLeftToLoad--;\n        callback === null || callback === void 0 ? void 0 : callback(images[imageFile]);\n    });\n}\nfunction requireFrame(imageFile, { x, y, w, h }, callback) {\n    const image = requireImage(imageFile, callback);\n    return { image, x, y, w, h };\n}\nfunction finishedLoadingImages() {\n    return numberOfImagesLeftToLoad === 0;\n}\n// Modified from http://maxpixel.freegreatpicture.com/Seamless-Sand-Background-Texture-1657465\n// const shallowSource = {image: requireImage('gfx/map/shallow.png'), x: 0, y: 0, w: 64, h: 64};\n// Modified from http://maxpixel.freegreatpicture.com/Background-Texture-Seamless-Stone-Rocks-1657467\n// Modified from http://maxpixel.freegreatpicture.com/Seamless-Sand-Background-Texture-1657465\n// const sandSource = {image: requireImage('gfx/map/sand.png'), y: 0, y: 0, w: 64, h: 64};\n// Modified from https://pixabay.com/en/seamless-tileable-texture-ground-1807373/\n// const dirtSource = {image: requireImage('gfx/map/dirt2.png'), y: 0, y: 0, w: 72, h: 72};\n// Modified from https://pixabay.com/en/retro-flower-pattern-design-batik-1422325/\n//const grassSource = {image: requireImage('gfx/map/grass.png'), y: 0, y: 0, w: 72, h: 72};\n//const forestSource = {image: requireImage('gfx/map/forest.png'),y: 0, y: 0, w: 72, h: 72};\n// Modified from https://pixabay.com/en/seamless-texture-texture-ice-cold-219909/\n//export const iceSource = {image: requireImage('gfx/map/ice.png'), x: 0, y: 0, w: 64, h: 64};\n// Think this is FF1 ocean, will need to replace this at some point.\nconst [oceanTile, oceanTileContext] = (0,app_dom__WEBPACK_IMPORTED_MODULE_0__.createCanvasAndContext)(16, 16);\nconst oceanImage = requireImage('gfx/map/landscapeTiles.png', () => {\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(oceanTileContext, oceanSource, { ...oceanSource, x: 0, y: 0 });\n});\nconst oceanSource = { image: oceanImage, x: 1, y: 1, w: 16, h: 16 };\nconst shallowSource = { image: requireImage('gfx/map/landscapeTiles.png'), y: 35, x: 18, w: 16, h: 16 };\nconst sandSource = { image: requireImage('gfx/map/landscapeTiles.png'), y: 86, x: 18, w: 16, h: 16 };\nconst dirtSource = { image: requireImage('gfx/map/landscapeTiles.png'), y: 137, x: 18, w: 16, h: 16 };\nconst grassSource = { image: requireImage('gfx/map/landscapeTiles.png'), y: 188, x: 18, w: 16, h: 16 };\nconst forestSource = { image: requireImage('gfx/map/landscapeTiles.png'), y: 239, x: 18, w: 16, h: 16 };\nconst hillSource = { image: requireImage('gfx/map/landscapeTiles.png'), y: 290, x: 18, w: 16, h: 16 };\nconst mountainSource = { image: requireImage('gfx/map/landscapeTiles.png'), y: 341, x: 18, w: 16, h: 16 };\n// This should be y=392 and h=16, but the first row is slightly transparent for some reason.\nconst iceSource = { image: requireImage('gfx/map/landscapeTiles.png'), y: 393, x: 18, w: 16, h: 15 };\n// Might use this for a new round of tiles: http://alucus.deviantart.com/art/Pallet-town-tiles-157214973\n// http://opengameart.org/content/treasure-chests\nconst chestSource = { image: requireImage('gfx/chest-open.png'), x: 0, y: 0, w: 32, h: 32 };\n// Icons by Hillary originally created for Treasure Tycoon\nconst coinImage = requireImage('gfx/loot/moneyIcon.png', () => {\n    outlinedMoneyContext.globalAlpha = 0.7;\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedImage)(outlinedMoneyContext, 'white', 1, moneySource, { ...moneySource, x: 1, y: 1 });\n});\nconst moneySource = { image: coinImage, x: 64, y: 64, w: 24, h: 24 };\n// Original images by Hillary created for Geo Crasher\nconst personSource = requireFrame('gfx/person.png', { x: 0, y: 0, w: 144, h: 192 }, () => {\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedImage)(outlinedPersonContext, 'white', 1, personSource, { x: 0, y: 0, w: 144, h: 192 });\n    app_dom__WEBPACK_IMPORTED_MODULE_0__.debugCanvas; //(outlinedPersonImage);\n});\n// The person image has enough room between cells for the outline, except at the bottom of the image.\nconst [outlinedPersonImage, outlinedPersonContext] = (0,app_dom__WEBPACK_IMPORTED_MODULE_0__.createCanvasAndContext)(144, 194);\nconst [outlinedMoneyImage, outlinedMoneyContext] = (0,app_dom__WEBPACK_IMPORTED_MODULE_0__.createCanvasAndContext)(moneySource.w + 2, moneySource.h + 2);\nconst outlinedMoneySource = { image: outlinedMoneyImage, x: 0, y: 0, w: 26, h: 26 };\nconst avatarDimensions = { w: 48, h: 49 };\nconst walkFrames = [0, 1, 0, 2];\nconst avatarAnimations = {\n    up: createAnimation(outlinedPersonImage, avatarDimensions, { x: 0, y: 2, top: 1, cols: 3, frameMap: walkFrames }),\n    down: createAnimation(outlinedPersonImage, avatarDimensions, { x: 0, y: 0, top: 1, cols: 3, frameMap: walkFrames }),\n    left: createAnimation(outlinedPersonImage, avatarDimensions, { x: 0, y: 1, top: 1, cols: 3, frameMap: walkFrames }),\n    right: createAnimation(outlinedPersonImage, avatarDimensions, { x: 0, y: 3, top: 1, cols: 3, frameMap: walkFrames }),\n};\n// From open source game prototyping images: http://www.lostgarden.com/2007/05/dancs-miraculously-flexible-game.html\nconst heartSource = { image: requireImage('gfx/loot/heart.png'), x: 0, y: 0, w: 50, h: 50 };\nconst bugSource = { image: requireImage('gfx/monsters/bug.png'), x: 0, y: 0, w: 100, h: 100 };\nconst orangeGemSource = { image: requireImage('gfx/loot/orangeGem.png'), x: 0, y: 0, w: 50, h: 55 };\nconst greenGemSource = { image: requireImage('gfx/loot/greenGem.png'), x: 0, y: 0, w: 50, h: 55 };\nconst blueGemSource = { image: requireImage('gfx/loot/blueGem.png'), x: 0, y: 0, w: 50, h: 55 };\n// Icons from http://opengameart.org/content/496-pixel-art-icons-for-medievalfantasy-rpg\nconst swordSource = { image: requireImage('gfx/loot/sword.png'), x: 0, y: 0, w: 34, h: 34 };\nconst shieldSource = { image: requireImage('gfx/loot/shield.png'), x: 0, y: 0, w: 34, h: 34 };\nconst shoeSource = { image: requireImage('gfx/shoe.png'), x: 0, y: 0, w: 34, h: 34 };\nconst clockSource = { image: requireImage('gfx/loot/clock.png'), x: 0, y: 0, w: 34, h: 34 };\nconst scrollSource = { image: requireImage('gfx/loot/scroll.png'), x: 0, y: 0, w: 34, h: 34 };\nconst portalSource = { image: requireImage('gfx/map/portal.png'), x: 0, y: 0, w: 34, h: 34 };\nconst shellSource = { image: requireImage('gfx/map/shell.png'), x: 0, y: 0, w: 34, h: 34 };\nconst exitSource = { image: requireImage('gfx/map/exit.png'), x: 0, y: 0, w: 34, h: 34 };\nconst magicStoneSource = { image: requireImage('gfx/loot/magicStone.png'), x: 0, y: 0, w: 34, h: 34 };\nconst treasureMapSource = { image: requireImage('gfx/map/map.png'), x: 0, y: 0, w: 34, h: 34 };\n// Icon by Chris Brewer originally created for Treasure Tycoon\nconst upArrows = { image: requireImage('gfx/upArrows.png'), x: 0, y: 0, w: 32, h: 32 };\n// Trash icon from: https://upload.wikimedia.org/wikipedia/commons/thumb/7/7d/Trash_font_awesome.svg/480px-Trash_font_awesome.svg.png\nconst trashSource = { image: requireImage('gfx/trash.png'), x: 0, y: 0, w: 480, h: 480 };\n// Image by Noah originally created for Lazy RPG\nconst turtleSource = { image: requireImage('gfx/monsters/turtle.png'), x: 0, y: 0, w: 128, h: 128 };\n// Modified version of https://www.toptal.com/designers/subtlepatterns/rocky-wall/\nconst darkStoneImage = requireImage('gfx/darkstone.png');\n// https://www.toptal.com/designers/subtlepatterns/old-map/\nconst oldMapImage = requireImage('gfx/oldMap.png');\n// Requires Attribution (http://creativecommons.org/licenses/by/3.0/)\n// http://opengameart.org/content/monsterboy-in-wonder-world-mockup-assets\nconst waspSource = { image: requireImage('gfx/monsters/wasp.png'), x: 0, y: 0, w: 32, h: 32 };\nconst fungusSource = { image: requireImage('gfx/monsters/fungus.png'), x: 0, y: 0, w: 32, h: 32 };\nconst crabSource = { image: requireImage('gfx/monsters/crab.png'), x: 0, y: 0, w: 32, h: 32 };\nconst snailSource = { image: requireImage('gfx/monsters/snail.png'), x: 0, y: 0, w: 32, h: 32 };\n\n\n//# sourceURL=webpack://geocrasher/./app/images.ts?");

/***/ }),

/***/ "./app/journeyMode.ts":
/*!****************************!*\
  !*** ./app/journeyMode.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getJourneyButton\": () => (/* binding */ getJourneyButton),\n/* harmony export */   \"getMonsterPowerForJourneyMode\": () => (/* binding */ getMonsterPowerForJourneyMode)\n/* harmony export */ });\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n\n\n\n\n\nconst journeyButton = {\n    onClick(state) {\n        if (state.currentScene === 'journey') {\n            endJourneyMode(state);\n            return;\n        }\n        if (state.currentScene === 'map') {\n            if (!state.selectedTile) {\n                throw new Error('Expected state.selectedTile to be defined');\n            }\n            startJourneyMode(state, state.selectedTile);\n        }\n    },\n    isVisible(state) {\n        const { selectedTile } = state;\n        if (!state.world.currentPosition) {\n            return false;\n        }\n        if (state.battle.engagedMonster) {\n            return false;\n        }\n        if (state.currentScene === 'journey') {\n            // This button is used to exit journey mode while in journey mode.\n            return true;\n        }\n        if (state.currentScene !== 'map') {\n            return false;\n        }\n        if (!selectedTile) {\n            return false;\n        }\n        if (selectedTile.monsterMarker || selectedTile.dungeonMarker) {\n            return false;\n        }\n        // When we add voyage mode, we can remove this requirement and\n        // just have this display voyage mode for level 0 tiles.\n        if (selectedTile.level < 1) {\n            return false;\n        }\n        return true;\n    },\n    render(context, state) {\n        if (state.currentScene === 'journey' || state.currentScene === 'voyage') {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_2__.exitSource, this.target);\n        }\n        else {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_2__.shoeSource, this.target);\n        }\n    },\n    updateTarget(state) {\n        const { canvas, iconSize } = state.display;\n        const w = iconSize;\n        const h = iconSize;\n        // Bottom center of the screen.\n        this.target = {\n            x: 10,\n            y: canvas.height - 10 - h,\n            w,\n            h,\n        };\n    },\n    target: { x: 0, y: 0, w: 0, h: 0 },\n};\nfunction getJourneyButton() {\n    return journeyButton;\n}\nfunction startJourneyMode(state, tile) {\n    if (!state.world.currentPosition) {\n        throw new Error('Expected state.world.currentPosition to be defined');\n    }\n    // Set the origin so that the player always starts journey mode in the center of\n    // the tiles at [0, 0].\n    state.world.journeyModeOrigin = [\n        state.world.currentPosition[0] - app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.gridLength / 2,\n        state.world.currentPosition[1] - app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.gridLength / 2,\n    ];\n    state.world.journeyModePower = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_3__.getTilePower)(state, tile);\n    state.world.journeyModeTileLevel = tile.level;\n    const maxInitialMonsterPower = getMonsterPowerForJourneyMode(state, state.world.journeyModePower + 0.5);\n    state.world.journeyModeNextBossLevel = Math.floor(maxInitialMonsterPower);\n    state.world.savedTiles = state.world.allTiles;\n    state.world.allTiles = {};\n    state.saved.radius = app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.minRadius;\n    // This needs to be called after `getTilePower`, otherwise\n    // the tile power won't be generated correctly.\n    (0,app_state__WEBPACK_IMPORTED_MODULE_4__.pushScene)(state, 'journey');\n}\nfunction endJourneyMode(state) {\n    (0,app_state__WEBPACK_IMPORTED_MODULE_4__.popScene)(state);\n    state.world.allTiles = state.world.savedTiles;\n    state.saved.radius = app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.minRadius;\n}\nfunction getMonsterPowerForJourneyMode(state, tilePower) {\n    return state.world.journeyModeTileLevel / 2 + 2 * (tilePower - 1);\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/journeyMode.ts?");

/***/ }),

/***/ "./app/loot.ts":
/*!*********************!*\
  !*** ./app/loot.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addLootToTile\": () => (/* binding */ addLootToTile),\n/* harmony export */   \"checkToGenerateLootForTile\": () => (/* binding */ checkToGenerateLootForTile),\n/* harmony export */   \"collectLoot\": () => (/* binding */ collectLoot),\n/* harmony export */   \"drawCollectCoinsButton\": () => (/* binding */ drawCollectCoinsButton),\n/* harmony export */   \"drawLootTotals\": () => (/* binding */ drawLootTotals),\n/* harmony export */   \"generateLootCoins\": () => (/* binding */ generateLootCoins),\n/* harmony export */   \"getCollectButton\": () => (/* binding */ getCollectButton),\n/* harmony export */   \"getCollectionRadius\": () => (/* binding */ getCollectionRadius),\n/* harmony export */   \"getWeightedPowerup\": () => (/* binding */ getWeightedPowerup),\n/* harmony export */   \"makeMagicStoneLoot\": () => (/* binding */ makeMagicStoneLoot),\n/* harmony export */   \"makeTreasureChestLoot\": () => (/* binding */ makeTreasureChestLoot),\n/* harmony export */   \"makeTreasureMapLoot\": () => (/* binding */ makeTreasureMapLoot),\n/* harmony export */   \"updateLootCollection\": () => (/* binding */ updateLootCollection),\n/* harmony export */   \"updateMapLoot\": () => (/* binding */ updateMapLoot),\n/* harmony export */   \"updateTileLoot\": () => (/* binding */ updateTileLoot)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_utils_skills__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/skills */ \"./app/utils/skills.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\n\n\n\n\nclass CoinLootClass {\n    constructor(frame, value) {\n        this.frame = frame;\n        this.value = value;\n        this.type = 'coins';\n    }\n    onObtain(state) {\n        var _a;\n        state.saved.coins += this.value;\n        state.loot.coinsCollected = ((_a = state.loot.coinsCollected) !== null && _a !== void 0 ? _a : 0) + this.value;\n    }\n}\nclass TreasureChestClass {\n    constructor(value) {\n        this.value = value;\n        this.type = 'treasureChest';\n        this.frame = app_images__WEBPACK_IMPORTED_MODULE_3__.chestSource;\n    }\n    onObtain(state) {\n        var _a;\n        state.saved.coins += this.value;\n        state.loot.coinsCollected = ((_a = state.loot.coinsCollected) !== null && _a !== void 0 ? _a : 0) + this.value;\n    }\n}\nclass HealthLootClass {\n    constructor(value) {\n        this.value = value;\n        this.type = 'health';\n        this.frame = app_images__WEBPACK_IMPORTED_MODULE_3__.heartSource;\n        this.scale = 0.5;\n    }\n    onObtain(state) {\n        state.saved.avatar.healthBonus += this.value;\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.updatePlayerStats)(state);\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.gainHealth)(state, Math.round(2 * this.value * (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.getLevelBonus)(state)));\n        showStats(state);\n    }\n}\nclass AttackLootClass {\n    constructor(value) {\n        this.value = value;\n        this.type = 'attack';\n        this.frame = app_images__WEBPACK_IMPORTED_MODULE_3__.swordSource;\n        this.scale = 0.75;\n    }\n    onObtain(state) {\n        state.saved.avatar.attackBonus += this.value;\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.updatePlayerStats)(state);\n        showStats(state);\n    }\n}\nclass DefenseLootClass {\n    constructor(value) {\n        this.value = value;\n        this.type = 'defense';\n        this.frame = app_images__WEBPACK_IMPORTED_MODULE_3__.shieldSource;\n        this.scale = 0.75;\n    }\n    onObtain(state) {\n        state.saved.avatar.defenseBonus += this.value;\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.updatePlayerStats)(state);\n        showStats(state);\n    }\n}\nclass MagicStoneLootClass {\n    constructor() {\n        this.type = 'magicStone';\n        this.frame = app_images__WEBPACK_IMPORTED_MODULE_3__.magicStoneSource;\n    }\n    onObtain(state) {\n        if (state.currentScene === 'journey') {\n            state.saved.world.journeySkillPoints++;\n        }\n        else if (state.currentScene === 'dungeon') {\n            state.saved.world.dungeonLevelCap += 2;\n        }\n        // Display loot indication a bit longer for skill point bonus.\n        state.loot.lootCollectedTime = state.time + 2000;\n    }\n}\nclass TreasureMapLootClass {\n    constructor(value) {\n        this.value = value;\n        this.type = 'treasureMap';\n        this.frame = app_images__WEBPACK_IMPORTED_MODULE_3__.treasureMapSource;\n        this.scale = 0.5;\n    }\n    onObtain(state) {\n        state.saved.treasureHunt.mapCount += this.value;\n        state.saved.treasureHunt.hadMap = true;\n    }\n}\nconst coinLoot = [\n    new CoinLootClass({ image: app_images__WEBPACK_IMPORTED_MODULE_3__.coinImage, x: 0, y: 0, w: 16, h: 16 }, 1),\n    new CoinLootClass({ image: app_images__WEBPACK_IMPORTED_MODULE_3__.coinImage, x: 0, y: 32, w: 20, h: 20 }, 5),\n    new CoinLootClass({ image: app_images__WEBPACK_IMPORTED_MODULE_3__.coinImage, x: 0, y: 64, w: 24, h: 24 }, 20),\n    new CoinLootClass({ image: app_images__WEBPACK_IMPORTED_MODULE_3__.coinImage, x: 32, y: 0, w: 16, h: 16 }, 100),\n    new CoinLootClass({ image: app_images__WEBPACK_IMPORTED_MODULE_3__.coinImage, x: 32, y: 32, w: 20, h: 20 }, 500),\n    new CoinLootClass({ image: app_images__WEBPACK_IMPORTED_MODULE_3__.coinImage, x: 32, y: 64, w: 24, h: 24 }, 2000),\n    new CoinLootClass({ image: app_images__WEBPACK_IMPORTED_MODULE_3__.coinImage, x: 64, y: 0, w: 16, h: 16 }, 10000),\n    new CoinLootClass({ image: app_images__WEBPACK_IMPORTED_MODULE_3__.coinImage, x: 64, y: 32, w: 20, h: 20 }, 50000),\n    new CoinLootClass({ image: app_images__WEBPACK_IMPORTED_MODULE_3__.coinImage, x: 64, y: 64, w: 24, h: 24 }, 200000),\n];\nfunction updateMapLoot(state) {\n    state.loot.lootInRadius = [];\n    state.loot.lootInMonsterRadius = [];\n    updateLootCollection(state);\n    for (const mapTile of state.world.activeTiles) {\n        updateTileLoot(state, mapTile);\n    }\n}\nfunction checkToGenerateLootForTile(state, tile) {\n    if (tile.level < 0)\n        return;\n    // Tiles around the start of journey/voyage mode do not generate loot.\n    if (state.currentScene === 'journey' || state.currentScene === 'voyage') {\n        if (tile.journeyDistance < app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.emptyJourneyRadius) {\n            return;\n        }\n    }\n    // Only generate coins if there are fewer than 2 loot markers currently.\n    if (tile.lootMarkers.length < 2) {\n        const coins = Math.ceil((.5 + Math.random()) * (0,app_utils_world__WEBPACK_IMPORTED_MODULE_8__.getTilePower)(state, tile) * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getMoneySkillBonus)(state) * Math.pow(4, tile.level) / 3);\n        const coinDrops = generateLootCoins(coins, 1);\n        for (const coinDrop of coinDrops) {\n            addLootToTile(state, tile, coinDrop);\n        }\n    }\n    checkToGeneratePowerUp(state, tile);\n}\nfunction checkToGeneratePowerUp(state, tile) {\n    if (state.globalPosition.isFastMode || state.globalPosition.isFixingGPS)\n        return;\n    // Only one powerup per tile, and no powerups spawn on shallow water.\n    if (tile.powerupMarker || tile.level < 1)\n        return;\n    const isJourneyMode = state.currentScene === 'journey' || state.currentScene === 'voyage';\n    let chanceToSpawn = isJourneyMode\n        // In journey mode chance to spawn powerup is a flat chance based on distance from the starting location\n        // that maxes out at 10%\n        ? Math.min(0.1, 0.01 * tile.journeyDistance / app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength)\n        // In the regular map scene chance to spawn powerups is 10% max and decreases the better the tile is\n        // as well as with the current number of active powerups.\n        : 0.1 * ((4 - state.loot.activePowerupMarkers.size) / 4) * ((app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.maxTileLevel + 1 - tile.level) / (app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.maxTileLevel));\n    if (Math.random() > chanceToSpawn) {\n        return;\n    }\n    const value = (.4 + Math.random() * .2) * (0,app_utils_world__WEBPACK_IMPORTED_MODULE_8__.getTilePower)(state, tile) * Math.pow(1.3, tile.level - 1);\n    // On the world map only there is a small chance to find a treasure map.\n    // I guess this could also be added to dungeons, but then you might miss a large\n    // powerup for a map which doesn't seem great.\n    const lootMarker = addLootToTile(state, tile, getWeightedPowerup(state, value, [makeTreasureMapLoot]));\n    tile.powerupMarker = lootMarker;\n    state.loot.activePowerupMarkers.add(lootMarker);\n}\nfunction addLootToTile(state, tile, loot) {\n    const realCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_8__.toRealCoords)(state, [tile.x, tile.y]);\n    const lootMarker = {\n        loot, tile,\n        x: realCoords[0] + app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength / 2,\n        y: realCoords[1] + app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength / 2,\n        tx: realCoords[0] + Math.random() * app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength,\n        ty: realCoords[1] + Math.random() * app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength,\n    };\n    tile.lootMarkers.push(lootMarker);\n    return lootMarker;\n}\nfunction getWeightedPowerup(state, value, additionalLoot = []) {\n    const lootGeneratorMethod = app_utils_Random__WEBPACK_IMPORTED_MODULE_6__[\"default\"].element([\n        makeHealthLoot, makeHealthLoot, makeHealthLoot, makeHealthLoot,\n        makeHealthLoot, makeHealthLoot, makeHealthLoot, makeHealthLoot,\n        makeAttackLoot, makeAttackLoot, makeAttackLoot,\n        makeDefenseLoot, makeDefenseLoot, makeDefenseLoot,\n        ...additionalLoot,\n    ]);\n    return lootGeneratorMethod(state, value);\n}\nfunction makeHealthLoot(state, value) {\n    return new HealthLootClass(Math.ceil(4 * value * (1 + (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillValue)(state, 'healthPower'))));\n}\nfunction makeAttackLoot(state, value) {\n    return new AttackLootClass(Math.ceil(value * (1 + (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillValue)(state, 'attackPower'))));\n}\nfunction makeDefenseLoot(state, value) {\n    return new DefenseLootClass(Math.ceil(value * (1 + (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillValue)(state, 'defensePower'))));\n}\nconst magicStoneLoot = new MagicStoneLootClass();\nfunction makeMagicStoneLoot() {\n    return magicStoneLoot;\n}\nfunction makeTreasureChestLoot(value) {\n    return new TreasureChestClass(value);\n}\nfunction makeTreasureMapLoot(state, value) {\n    return new TreasureMapLootClass(Math.ceil(value));\n}\nfunction updateTileLoot(state, tile) {\n    for (let i = 0; i < tile.lootMarkers.length; i++) {\n        const lootMarker = tile.lootMarkers[i];\n        // Remove all non coin loot during state.globalPosition.isFastMode.\n        if (state.globalPosition.isFastMode && lootMarker === tile.powerupMarker) {\n            delete tile.powerupMarker;\n            tile.lootMarkers.splice(i--, 1);\n            continue;\n        }\n        if (state.globalPosition.isFastMode && lootMarker === tile.gemMarker) {\n            delete tile.gemMarker;\n            tile.lootMarkers.splice(i--, 1);\n            continue;\n        }\n        lootMarker.x = (lootMarker.x + lootMarker.tx) / 2;\n        lootMarker.y = (lootMarker.y + lootMarker.ty) / 2;\n        lootMarker.isInAvatarRadius = isLootInRadius(state, lootMarker);\n        lootMarker.isInMonsterRadius = !state.globalPosition.isFastMode && lootMarker.loot.type !== 'gem' && isPointInMonsterRadius(state, lootMarker.x, lootMarker.y);\n        if (state.globalPosition.isFastMode && lootMarker.isInAvatarRadius) {\n            if (state.loot.collectingLoot.indexOf(lootMarker) < 0) {\n                state.loot.collectingLoot.push(lootMarker);\n            }\n        }\n        else if (lootMarker.isInAvatarRadius && !lootMarker.isInMonsterRadius) {\n            state.loot.lootInRadius.push(lootMarker);\n        }\n        if (lootMarker.isInMonsterRadius) {\n            state.loot.lootInMonsterRadius.push(lootMarker);\n        }\n    }\n}\nfunction isPointInMonsterRadius(state, x, y) {\n    for (const monster of state.world.activeMonsterMarkers) {\n        if ((0,app_utils_index__WEBPACK_IMPORTED_MODULE_5__.getDistance)([monster.tile.centerX, monster.tile.centerY], [x, y]) <= monster.monster.radius) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction collectLoot(state) {\n    // Don't collect loot until we are finished collecting the current batch of loot.\n    if (state.loot.collectingLoot.length) {\n        return;\n    }\n    (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.resetLootTotals)(state);\n    state.saved.radius = app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.minRadius;\n    for (const lootMarker of state.loot.lootInRadius) {\n        state.loot.collectingLoot.push(lootMarker);\n    }\n}\nfunction isLootInRadius(state, loot) {\n    if (!state.world.currentPosition) {\n        return false;\n    }\n    const actualRadius = getCollectionRadius(state);\n    const dx = state.world.currentPosition[0] - loot.x;\n    const dy = state.world.currentPosition[1] - loot.y;\n    return dx * dx + dy * dy < actualRadius * actualRadius;\n}\nfunction getCollectionRadius(state) {\n    return state.saved.radius * Math.sqrt((1 + (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillValue)(state, 'radius')));\n}\nfunction updateLootCollection(state) {\n    const avatarPosition = (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.getAvatarPosition)(state);\n    const { collectingLoot } = state.loot;\n    if (!avatarPosition || !collectingLoot.length) {\n        return;\n    }\n    // Move all loot towards the player\n    for (let i = 0; i < collectingLoot.length; i++) {\n        const lootMarker = collectingLoot[i];\n        // Pull coins towards the player's position, the front of the queue quicker than the rest.\n        let factor = Math.min(10, 3 * i + 1);\n        if (state.dungeon.currentDungeon) {\n            // Loot is collected at a constant rate in dungeons since there is only one piece of loot collected at a time.\n            factor = 5;\n        }\n        else if (state.globalPosition.isFastMode) {\n            // Loot is collected at a constant rate in fast mode.\n            factor = 2;\n        }\n        // By default, loot will move towards its target location so we need to udpate both the actual + target locations.\n        lootMarker.x = lootMarker.tx = (avatarPosition[0] * 2 + lootMarker.tx * factor) / (factor + 2);\n        lootMarker.y = lootMarker.ty = (avatarPosition[1] * 2 + lootMarker.ty * factor) / (factor + 2);\n        // Collect the loot if it is in range.\n        if ((0,app_utils_index__WEBPACK_IMPORTED_MODULE_5__.getDistance)(avatarPosition, [lootMarker.x, lootMarker.y]) < (state.globalPosition.isFastMode ? app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength / 10 : app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength / 20)) {\n            obtainloot(state, lootMarker);\n            collectingLoot.splice(i--, 1);\n        }\n    }\n    if (!collectingLoot.length) {\n        // Gain bonus coins after all loot has been collected.\n        state.saved.coins += Math.round(state.loot.coinsCollected * (state.loot.collectionBonus - 1));\n        (0,app_saveGame__WEBPACK_IMPORTED_MODULE_4__.saveGame)(state);\n    }\n}\nfunction obtainloot(state, lootMarker) {\n    state.loot.lootCollectedTime = Math.max(state.loot.lootCollectedTime, state.time);\n    if (state.globalPosition.isFastMode || state.dungeon.currentDungeon) {\n        state.loot.collectionBonus = 1;\n    }\n    else if (state.loot.collectionBonus < 2) {\n        // Gain 10% bonus coins up to 2x.\n        state.loot.collectionBonus += .1;\n    }\n    else {\n        // Gain 5% bonus coins after 2x.\n        state.loot.collectionBonus += .05;\n    }\n    const tile = lootMarker.tile;\n    if (tile.powerupMarker === lootMarker) {\n        delete tile.powerupMarker;\n    }\n    if (tile.gemMarker === lootMarker) {\n        delete tile.gemMarker;\n    }\n    const markerIndex = state.gems.gemMarkers.indexOf(lootMarker);\n    if (markerIndex >= 0) {\n        state.gems.gemMarkers.splice(markerIndex, 1);\n    }\n    state.loot.activePowerupMarkers.delete(lootMarker);\n    if (lootMarker.loot.onObtain) {\n        lootMarker.loot.onObtain(state);\n    }\n    tile.lootMarkers.splice(tile.lootMarkers.indexOf(lootMarker), 1);\n    if (!tile.exhaustedDuration) {\n        (0,app_utils_world__WEBPACK_IMPORTED_MODULE_8__.exhaustTile)(tile);\n    }\n}\nfunction showStats(state) {\n    state.loot.hideStatsAt = state.time + 1500;\n}\nfunction generateLootCoins(amount, limit) {\n    let remainingAmount = amount;\n    // We will check through the coin loot amounts starting with the largest amount.\n    let index = coinLoot.length - 1;\n    let drops = 0;\n    const loot = [];\n    while (remainingAmount > 0 && index >= 0 && drops < limit) {\n        while (coinLoot[index].value <= remainingAmount && drops < limit) {\n            remainingAmount -= coinLoot[index].value;\n            loot.push(coinLoot[index]);\n            drops++;\n        }\n        index--;\n    }\n    return loot;\n}\nconst collectButton = {\n    onClick(state) {\n        var _a;\n        if (state.currentScene === 'map' || state.currentScene === 'journey') {\n            collectLoot(state);\n        }\n        else if (state.currentScene === 'dungeon') {\n            (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.resetLootTotals)(state);\n            for (const loot of (((_a = state.selectedTile) === null || _a === void 0 ? void 0 : _a.lootMarkers) || [])) {\n                if (state.loot.collectingLoot.indexOf(loot) <= 0) {\n                    state.loot.collectingLoot.push(loot);\n                }\n            }\n        }\n    },\n    isDisabled(state) {\n        if (state.currentScene === 'map' || state.currentScene === 'journey') {\n            return !state.loot.lootInRadius || state.loot.collectingLoot.length > 0;\n        }\n        if (state.currentScene === 'dungeon') {\n            return state.loot.collectingLoot.length > 0;\n        }\n        return false;\n    },\n    isVisible(state) {\n        var _a, _b;\n        if (state.currentScene === 'dungeon') {\n            return !!((_b = (_a = state.selectedTile) === null || _a === void 0 ? void 0 : _a.lootMarkers) === null || _b === void 0 ? void 0 : _b.length);\n        }\n        // Loot is automatically collected in voyage mode.\n        if (state.currentScene === 'map' || state.currentScene === 'journey') {\n            return !state.selectedTile;\n        }\n        return false;\n    },\n    render(context, state) {\n        var _a, _b;\n        const { iconSize } = state.display;\n        context.save();\n        let lootCount = 0;\n        if (state.dungeon.currentDungeon) {\n            lootCount = ((_b = (_a = state.selectedTile) === null || _a === void 0 ? void 0 : _a.lootMarkers) === null || _b === void 0 ? void 0 : _b.length) || 0;\n        }\n        else {\n            lootCount = state.loot.lootInRadius.length;\n        }\n        if (!lootCount) {\n            context.globalAlpha *= .6;\n        }\n        context.textBaseline = 'bottom';\n        context.textAlign = 'left';\n        context.font = Math.floor(3 * iconSize / 4) + 'px sans-serif';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_3__.chestSource, { x: this.target.x, y: this.target.y, w: iconSize, h: iconSize });\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, 'x' + lootCount, 'white', 'black', this.target.x + this.target.w / 2, this.target.y + this.target.h);\n        context.restore();\n    },\n    updateTarget(state) {\n        const { canvas, iconSize } = state.display;\n        const w = iconSize;\n        // Upgrade Button is in the bottom center.\n        this.target = {\n            x: Math.floor((canvas.width - w) / 2),\n            y: canvas.height - 10 - iconSize,\n            w,\n            h: iconSize,\n        };\n    },\n    target: { x: 0, y: 0, w: 0, h: 0 }\n};\nfunction getCollectButton() {\n    return collectButton;\n}\nfunction drawCollectCoinsButton(context, state) {\n    collectButton.render(context, state);\n}\nfunction drawLootTotals(context, state, fadeTime = 2000) {\n    const { coinsCollected, collectionBonus, initialAttack, initialDefense, initialLevel, initialMaxHealth, initialSkillPoints, lootCollectedTime } = state.loot;\n    if (state.time > lootCollectedTime + fadeTime && (!state.globalPosition.isFastMode || coinsCollected === 0)) {\n        return;\n    }\n    const { canvas, iconSize } = state.display;\n    context.save();\n    context.globalAlpha = state.globalPosition.isFastMode ? 1 : Math.min(1, 2 - (state.time - lootCollectedTime) / (fadeTime / 2));\n    const fontSize = Math.floor(3 * iconSize / 4);\n    context.font = fontSize + 'px sans-serif';\n    context.textAlign = 'center';\n    context.textBaseline = 'bottom';\n    let top = canvas.height / 2 + 2;\n    if (coinsCollected > 0) {\n        if (collectionBonus > 1) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, (0,app_utils_index__WEBPACK_IMPORTED_MODULE_5__.abbreviateNumber)(coinsCollected) + 'x' + collectionBonus.toFixed(2), 'gold', 'black', canvas.width / 2, canvas.height / 2 - 2);\n        }\n        else {\n            top = Math.floor((canvas.height - iconSize) / 2);\n        }\n        context.textBaseline = 'middle';\n        context.textAlign = 'left';\n        const totalCoinsText = '+' + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_5__.abbreviateNumber)(Math.round(coinsCollected * collectionBonus));\n        const left = Math.floor(canvas.width / 2 - (context.measureText(totalCoinsText).width + iconSize) / 2);\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, totalCoinsText, 'gold', 'black', left + iconSize, top + iconSize / 2);\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_3__.outlinedMoneySource, { x: left, y: top, w: iconSize, h: iconSize });\n    }\n    const powerUpFontSize = Math.floor(iconSize / 2);\n    let powerUpWidth = 0;\n    const currentAttack = (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.getAttackWithoutHealthBonuses)(state);\n    const currentDefense = (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.getDefenseWithoutHealthBonuses)(state);\n    const healthBonusText = '+' + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_5__.abbreviateNumber)(state.avatar.maxHealth - initialMaxHealth);\n    const attackBonusText = '+' + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_5__.abbreviateNumber)(currentAttack - initialAttack);\n    const defenseBonusText = '+' + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_5__.abbreviateNumber)(currentDefense - initialDefense);\n    context.font = powerUpFontSize + 'px sans-serif';\n    if (state.avatar.maxHealth !== initialMaxHealth)\n        powerUpWidth += powerUpFontSize + context.measureText(healthBonusText).width;\n    if (currentAttack !== initialAttack)\n        powerUpWidth += powerUpFontSize + context.measureText(attackBonusText).width;\n    if (currentDefense !== initialDefense)\n        powerUpWidth += powerUpFontSize + context.measureText(defenseBonusText).width;\n    if (state.saved.avatar.level !== initialLevel) {\n        context.textAlign = 'center';\n        context.textBaseline = 'bottom';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, 'LEVEL UP', 'gold', 'black', canvas.width / 2, canvas.height / 2 - fontSize - powerUpFontSize - 8);\n    }\n    else if ((0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getTotalSkillPoints)(state) !== initialSkillPoints) {\n        context.textAlign = 'center';\n        context.textBaseline = 'bottom';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, '+1 Skill Point', 'gold', 'black', canvas.width / 2, canvas.height / 2 - fontSize - powerUpFontSize - 8);\n    }\n    if (powerUpWidth > 0) {\n        let left = (canvas.width - powerUpWidth) / 2;\n        context.textAlign = 'left';\n        context.textBaseline = 'middle';\n        const bottom = canvas.height / 2 - fontSize - 4;\n        if (state.avatar.maxHealth !== initialMaxHealth) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedImage)(context, 'white', 2, app_images__WEBPACK_IMPORTED_MODULE_3__.heartSource, { x: left, y: bottom - powerUpFontSize, w: powerUpFontSize, h: powerUpFontSize });\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, healthBonusText, 'white', 'black', left + powerUpFontSize, bottom - powerUpFontSize / 2);\n            left += powerUpFontSize + context.measureText(healthBonusText).width;\n        }\n        if (currentAttack !== initialAttack) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedImage)(context, 'white', 2, app_images__WEBPACK_IMPORTED_MODULE_3__.swordSource, { x: left, y: bottom - powerUpFontSize, w: powerUpFontSize, h: powerUpFontSize });\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, attackBonusText, 'white', 'black', left + powerUpFontSize, bottom - powerUpFontSize / 2);\n            left += powerUpFontSize + context.measureText(attackBonusText).width;\n        }\n        if (currentDefense !== initialDefense) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedImage)(context, 'white', 2, app_images__WEBPACK_IMPORTED_MODULE_3__.shieldSource, { x: left, y: bottom - powerUpFontSize, w: powerUpFontSize, h: powerUpFontSize });\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, defenseBonusText, 'white', 'black', left + powerUpFontSize, bottom - powerUpFontSize / 2);\n        }\n    }\n    context.restore();\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/loot.ts?");

/***/ }),

/***/ "./app/mainLoop.ts":
/*!*************************!*\
  !*** ./app/mainLoop.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"startMainLoop\": () => (/* binding */ startMainLoop)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_battle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/battle */ \"./app/battle.ts\");\n/* harmony import */ var app_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/context */ \"./app/context.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_globalPosition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/globalPosition */ \"./app/globalPosition.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/scenes/dungeonScene */ \"./app/scenes/dungeonScene.ts\");\n/* harmony import */ var app_scenes_mapScene__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/scenes/mapScene */ \"./app/scenes/mapScene.ts\");\n/* harmony import */ var app_scenes_treasureMapScene__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/scenes/treasureMapScene */ \"./app/scenes/treasureMapScene.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n/* harmony import */ var app_world__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/world */ \"./app/world.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\nlet mainLoopId;\nfunction startMainLoop() {\n    mainLoopId = setInterval(mainLoop, app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.frameLength);\n}\nfunction mainLoop() {\n    try {\n        const state = (0,app_state__WEBPACK_IMPORTED_MODULE_9__.getState)();\n        const { canvas } = state.display;\n        (0,app_globalPosition__WEBPACK_IMPORTED_MODULE_4__.checkToWatchPosition)(state);\n        if (state.globalPosition.lastPosition) {\n            // Make target coords always positive.\n            const targetPosition = [\n                state.globalPosition.lastPosition.coords.longitude + 360,\n                360 - state.globalPosition.lastPosition.coords.latitude\n            ];\n            if (!state.world.currentPosition || state.globalPosition.isFixingGPS) {\n                (0,app_world__WEBPACK_IMPORTED_MODULE_11__.setCurrentPosition)(state, targetPosition);\n            }\n            else {\n                // GPS provided position can jump around a bit, so ease towards the new location once we have a current position.\n                // Note that this kind of easing won't work well around the poles or the international dateline.\n                (0,app_world__WEBPACK_IMPORTED_MODULE_11__.setCurrentPosition)(state, [\n                    (state.world.currentPosition[0] * 9 + targetPosition[0]) / 10,\n                    (state.world.currentPosition[1] * 9 + targetPosition[1]) / 10,\n                ]);\n                const lastDirection = state.globalPosition.direction;\n                const dx = targetPosition[0] - state.world.currentPosition[0];\n                const dy = targetPosition[1] - state.world.currentPosition[1];\n                if (Math.abs(dx) >= Math.abs(dy)) {\n                    if (dx > 0)\n                        state.globalPosition.direction = 'right';\n                    else if (dx < 0)\n                        state.globalPosition.direction = 'left';\n                }\n                else {\n                    if (dy < 0)\n                        state.globalPosition.direction = 'up';\n                    else if (dy > 0)\n                        state.globalPosition.direction = 'down';\n                }\n                const exampleAnimation = app_images__WEBPACK_IMPORTED_MODULE_5__.avatarAnimations.up;\n                if (Math.abs(dx) < app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 200 && Math.abs(dy) < app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 200 &&\n                    // This is intended to prevent the animation from stopping mid walk cycle.\n                    state.avatar.animationTime % exampleAnimation.duration < app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.frameLength * exampleAnimation.frameDuration) {\n                    state.avatar.animationTime = 0;\n                }\n                else if (state.globalPosition.direction !== lastDirection) {\n                    // Start mid step when switching frames\n                    state.avatar.animationTime = app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.frameLength * exampleAnimation.frameDuration;\n                }\n                else {\n                    state.avatar.animationTime += app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.frameLength;\n                }\n            }\n            // Current position will be set by one of the two blocks above.\n            const currentPosition = state.world.currentPosition;\n            // Because everything is on root, this is messed up by the introduction of window.origin.\n            // Fixed by checking if it is a string, but really I shouldn't be using global vars everywhere.\n            if (!state.world.origin) {\n                state.world.origin = currentPosition;\n            }\n            let target = state.world.origin;\n            if (state.globalPosition.isFastMode\n                || state.globalPosition.isFixingGPS\n                || state.currentScene === 'journey'\n                || state.currentScene === 'voyage') {\n                target = currentPosition;\n            }\n            else if (state.currentScene === 'map' && state.selectedTile) {\n                target = [state.selectedTile.centerX, state.selectedTile.centerY];\n            }\n            else {\n                // Scroll towards the visible area when it is too far off screen.\n                const screenCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_10__.project)(state, currentPosition);\n                const scaleToUse = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_10__.getActualScale)(state);\n                if (screenCoords[0] < 120) {\n                    target[0] = currentPosition[0] + (canvas.width / 2 - 120) / scaleToUse;\n                }\n                if (screenCoords[0] > canvas.width - 120) {\n                    target[0] = currentPosition[0] - (canvas.width / 2 - 120) / scaleToUse;\n                }\n                if (screenCoords[1] < 120) {\n                    target[1] = currentPosition[1] + (canvas.height / 2 - 120) / scaleToUse;\n                }\n                if (screenCoords[1] > canvas.height - 120) {\n                    target[1] = currentPosition[1] - (canvas.height / 2 - 120) / scaleToUse;\n                }\n            }\n            if (!state.world.origin) {\n                state.world.origin = target;\n            }\n            else {\n                state.world.origin[0] = (state.world.origin[0] * 10 + target[0]) / 11;\n                state.world.origin[1] = (state.world.origin[1] * 10 + target[1]) / 11;\n            }\n        }\n        if (state.currentScene !== 'loading' && state.currentScene !== 'title') {\n            (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.updatePlayerStats)(state);\n        }\n        switch (state.currentScene) {\n            case 'loading':\n                // Show the title scene once all images are loaded.\n                if ((0,app_images__WEBPACK_IMPORTED_MODULE_5__.finishedLoadingImages)()) {\n                    state.currentScene = 'title';\n                }\n                break;\n            case 'journey':\n            case 'voyage':\n            case 'map':\n                (0,app_scenes_mapScene__WEBPACK_IMPORTED_MODULE_7__.updateMap)(state);\n                break;\n            case 'dungeon':\n                (0,app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_6__.updateDungeon)(state);\n                break;\n            case 'treasureMap':\n                (0,app_scenes_treasureMapScene__WEBPACK_IMPORTED_MODULE_8__.updateTreasureMap)(state);\n                break;\n        }\n        (0,app_battle__WEBPACK_IMPORTED_MODULE_1__.updateBattle)(state);\n        state.time += app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.frameLength;\n    }\n    catch (error) {\n        clearTimeout(mainLoopId);\n        console.log(error.message);\n        if (app_context__WEBPACK_IMPORTED_MODULE_2__.isDebugMode)\n            alert(error.message);\n        throw error;\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/mainLoop.ts?");

/***/ }),

/***/ "./app/monsters.ts":
/*!*************************!*\
  !*** ./app/monsters.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkToGenerateMonster\": () => (/* binding */ checkToGenerateMonster),\n/* harmony export */   \"drawTileMonster\": () => (/* binding */ drawTileMonster),\n/* harmony export */   \"makeBossMonster\": () => (/* binding */ makeBossMonster),\n/* harmony export */   \"makeMonster\": () => (/* binding */ makeMonster)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n/* harmony import */ var app_utils_skills__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/skills */ \"./app/utils/skills.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\n\n\n\n\n\n\n\nconst minMonsterRadius = app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength * 2 / 3;\nconst maxMonsterRadius = app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength * 4 / 3;\nfunction getMonsterPowerForTile(state, tile) {\n    // This formula is designed to make the monsters in journey mode have scaling\n    // similar to the tile selected for journey mode.\n    if (state.currentScene === 'journey') {\n        return state.world.journeyModeTileLevel / 2 + 2 * ((0,app_utils_world__WEBPACK_IMPORTED_MODULE_4__.getTilePower)(state, tile) - 1);\n    }\n    return tile.level / 2 + 2 * ((0,app_utils_world__WEBPACK_IMPORTED_MODULE_4__.getTilePower)(state, tile) - 1);\n}\nfunction makeBossMonster(state, monsterPower) {\n    const boss = makeMonster(state, monsterPower);\n    boss.maxHealth = boss.currentHealth = boss.maxHealth * 3;\n    boss.attack = Math.ceil(boss.attack * 1.1);\n    boss.defense = Math.ceil(boss.defense * 1.4);\n    boss.experience *= 4;\n    boss.isBoss = true;\n    boss.tint = { color: 'red', amount: 0.6 };\n    return boss;\n}\nfunction makeMonster(state, monsterPower) {\n    const monsterLevel = Math.max(1, Math.floor(monsterPower));\n    // Monsters gain 30% more power each level, and gain up to an additional 20% more power before leveling again.\n    const powerFactor = Math.pow(1.3, monsterLevel - 1) * (1 + Math.max(0, monsterPower - monsterLevel) / 5);\n    //const powerFactor = Math.pow(3, tile.level - 1) * getTilePower(tile);\n    const rollA = app_utils_Random__WEBPACK_IMPORTED_MODULE_7__[\"default\"].integerRange(-2, 2);\n    const rollB = app_utils_Random__WEBPACK_IMPORTED_MODULE_7__[\"default\"].integerRange(-2, 2);\n    const rollC = -rollA - rollB;\n    // Average roll is 1, min is 0.2 max is 1.8.\n    const rolls = [1 + .2 * rollA, 1 + .2 * rollB, 1 + .2 * rollC];\n    const healthRoll = app_utils_Random__WEBPACK_IMPORTED_MODULE_7__[\"default\"].removeElement(rolls);\n    const attackRoll = app_utils_Random__WEBPACK_IMPORTED_MODULE_7__[\"default\"].removeElement(rolls);\n    const defenseRoll = app_utils_Random__WEBPACK_IMPORTED_MODULE_7__[\"default\"].removeElement(rolls);\n    let name = 'Giant Bug', frame = app_images__WEBPACK_IMPORTED_MODULE_3__.bugSource;\n    if (healthRoll > attackRoll && healthRoll > defenseRoll) {\n        name = 'Shroomie';\n        frame = app_images__WEBPACK_IMPORTED_MODULE_3__.fungusSource;\n    }\n    else if (attackRoll > healthRoll && attackRoll > defenseRoll) {\n        name = 'Pincher';\n        frame = app_images__WEBPACK_IMPORTED_MODULE_3__.crabSource;\n    }\n    else if (defenseRoll > attackRoll && defenseRoll > healthRoll) {\n        name = 'Iron Shell';\n        frame = app_images__WEBPACK_IMPORTED_MODULE_3__.turtleSource;\n    }\n    else if (defenseRoll === attackRoll) {\n        name = 'Giant Bug';\n        frame = app_images__WEBPACK_IMPORTED_MODULE_3__.bugSource;\n    }\n    else if (defenseRoll >= healthRoll && defenseRoll >= attackRoll) {\n        name = 'Guard Snail';\n        frame = app_images__WEBPACK_IMPORTED_MODULE_3__.snailSource;\n    }\n    else if (attackRoll >= healthRoll && attackRoll >= defenseRoll) {\n        name = 'Stinger';\n        frame = app_images__WEBPACK_IMPORTED_MODULE_3__.waspSource;\n    }\n    // console.log([healthRoll, attackRoll, defenseRoll, name]);\n    const statReduction = 1 - (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_5__.getSkillValue)(state, 'conquerer');\n    const health = Math.round(30 * powerFactor * healthRoll * statReduction);\n    const attack = Math.round(5 * powerFactor * attackRoll * statReduction);\n    const defense = Math.round(5 * powerFactor * defenseRoll * statReduction);\n    return {\n        level: monsterLevel, name: name,\n        type: 'monster',\n        currentHealth: health,\n        maxHealth: health, attack, defense,\n        frame,\n        experience: Math.round(powerFactor * 2),\n        radius: app_utils_Random__WEBPACK_IMPORTED_MODULE_7__[\"default\"].range(minMonsterRadius, maxMonsterRadius),\n    };\n}\nfunction checkToGenerateMonster(state, tile, baseChance = 0.05) {\n    // Monsters cannot spawn in shallows or on top of dungeons.\n    if (tile.level < 1 || tile.dungeonMarker) {\n        return;\n    }\n    // Prevent monster from spawning within 2 tiles of another monster\n    for (const otherMonster of state.world.activeMonsterMarkers) {\n        if ((0,app_utils_index__WEBPACK_IMPORTED_MODULE_6__.getDistance)([tile.x, tile.y], [otherMonster.tile.x, otherMonster.tile.y]) <= 2) {\n            return;\n        }\n    }\n    const isJourneyMode = state.currentScene === 'journey' || state.currentScene === 'voyage';\n    // Don't generate monsters inside the empty radius in journey mode.\n    if (isJourneyMode && tile.journeyDistance < app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.emptyJourneyRadius) {\n        return;\n    }\n    // Chance to spawn a monster decreases with # of active monsters and the level of the tile.\n    const chanceToSpawn = isJourneyMode\n        // In Journey mode the base chance is the exact chance for a monster to spawn.\n        ? baseChance\n        // In the normal map scene, monsters are less likely to spawn the more active monsters are\n        // present and the more powerful the tile they are spawning on is.\n        : baseChance * ((8 - state.world.activeMonsterMarkers.length) / 8) * ((app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.maxTileLevel + 1 - tile.level) / (app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.maxTileLevel));\n    if (Math.random() > chanceToSpawn) {\n        return;\n    }\n    const monsterPower = getMonsterPowerForTile(state, tile);\n    const monster = (isJourneyMode && monsterPower >= state.world.journeyModeNextBossLevel + 1)\n        ? makeBossMonster(state, state.world.journeyModeNextBossLevel)\n        : makeMonster(state, getMonsterPowerForTile(state, tile));\n    if (monster.isBoss) {\n        state.world.journeyModeNextBossLevel += 2;\n    }\n    state.world.journeyModeNextBossLevel;\n    tile.monsterMarker = {\n        type: 'monster',\n        x: tile.x + app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength / 2,\n        y: tile.y + app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength / 2,\n        monster,\n        tile,\n    };\n    tile.monsterMarker.monster.marker = tile.monsterMarker;\n    state.world.activeMonsterMarkers.push(tile.monsterMarker);\n    if (tile === state.selectedTile) {\n        delete state.selectedTile;\n    }\n}\nfunction drawTileMonster(context, state, tile, scaleToUse) {\n    if (!tile.monsterMarker) {\n        return;\n    }\n    const monster = tile.monsterMarker.monster;\n    const baseAvatarAttack = (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.getAttackWithoutHealthBonuses)(state);\n    const baseAvatarDefense = (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.getDefenseWithoutHealthBonuses)(state);\n    let monsterScale = .8;\n    if (monster.maxHealth < state.avatar.maxHealth / 2\n        && monster.attack < baseAvatarAttack\n        && monster.defense < baseAvatarDefense) {\n        monsterScale = .6;\n    }\n    else if (monster.maxHealth > state.avatar.maxHealth / 2\n        && monster.attack > baseAvatarAttack\n        && monster.defense > baseAvatarDefense) {\n        monsterScale = 1;\n    }\n    if (monster.isBoss)\n        monsterScale = 1;\n    const w = Math.round(Math.min(tile.target.w * .9, 128) * monsterScale);\n    const h = Math.round(Math.min(tile.target.h * .9, 128) * monsterScale);\n    const target = {\n        x: tile.target.x + (tile.target.w - w) / 2,\n        y: tile.target.y + (tile.target.h - h) / 2,\n        w, h\n    };\n    let frame = monster.frame;\n    if (monster.tint) {\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.prepareTintedImage)();\n        frame = (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.getTintedImage)(frame, monster.tint);\n    }\n    if (tile === state.selectedTile) {\n        // Outline the monster and draw its radius when the tile is selected.\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedImage)(context, 'red', 2, frame, target);\n        context.save();\n        context.globalAlpha = .15;\n        context.fillStyle = 'red';\n        context.beginPath();\n        context.arc(tile.target.x + tile.target.w / 2, tile.target.y + tile.target.h / 2, tile.monsterMarker.monster.radius * scaleToUse, 0, 2 * Math.PI);\n        context.fill();\n        context.restore();\n    }\n    else {\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, frame, target);\n    }\n    // Draw the health bar if the monster is damaged or selected.\n    if (monster.currentHealth < monster.maxHealth || tile === state.selectedTile) {\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawBar)(context, { x: Math.round(target.x + target.w / 6), y: target.y - 5, w: Math.round(target.w * 2 / 3), h: 6 }, 'white', 'red', monster.currentHealth / monster.maxHealth);\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/monsters.ts?");

/***/ }),

/***/ "./app/saveGame.ts":
/*!*************************!*\
  !*** ./app/saveGame.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deleteSaveSlot\": () => (/* binding */ deleteSaveSlot),\n/* harmony export */   \"fixSavedData\": () => (/* binding */ fixSavedData),\n/* harmony export */   \"getDefaultSavedState\": () => (/* binding */ getDefaultSavedState),\n/* harmony export */   \"initializeSaveSlots\": () => (/* binding */ initializeSaveSlots),\n/* harmony export */   \"saveGame\": () => (/* binding */ saveGame)\n/* harmony export */ });\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n\nfunction getDefaultSavedState() {\n    return {\n        coins: 10,\n        radius: app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.minRadius,\n        avatar: {\n            level: 1,\n            experience: 0,\n            currentHealth: 100,\n            healthBonus: 100,\n            attackBonus: 8,\n            defenseBonus: 6,\n            skillLevels: {},\n        },\n        gems: {\n            recentLocations: []\n        },\n        treasureHunt: {\n            hadMap: false,\n            mapCount: 0,\n        },\n        world: {\n            dungeonLevelCap: 2,\n            journeySkillPoints: 0,\n            gemData: [{ history: [] }, { history: [] }, { history: [] }],\n            tiles: [],\n        },\n    };\n}\nfunction initializeSaveSlots(state) {\n    var _a;\n    const importedSaveDataString = window.localStorage.getItem('geocrasher2Saves');\n    const importedSaveData = importedSaveDataString ? JSON.parse(importedSaveDataString) : {};\n    let { saveSlots } = importedSaveData;\n    if (!saveSlots)\n        saveSlots = [];\n    for (let i = 0; i < 3; i++) {\n        saveSlots[i] = fixSavedData((_a = saveSlots[i]) !== null && _a !== void 0 ? _a : {});\n    }\n    state.saveSlots = saveSlots;\n}\nfunction deleteSaveSlot(state, saveSlotIndex) {\n    if (confirm('Are you sure you want to delete this save data? This cannot be undone.')) {\n        state.saveSlots[saveSlotIndex] = getDefaultSavedState();\n        window.localStorage.setItem('geocrasher2Saves', JSON.stringify(state.saveSlots));\n    }\n}\nfunction saveGame(state) {\n    if (state.saveSlotIndex < 0 || state.saveSlotIndex > 2) {\n        throw Error(`Attempted to save to invalid slot: ${state.saveSlotIndex}`);\n    }\n    prepareSavedData(state);\n    state.saveSlots[state.saveSlotIndex] = state.saved;\n    window.localStorage.setItem('geocrasher2Saves', JSON.stringify({ saveSlots: state.saveSlots }));\n}\nfunction prepareSavedData(state) {\n    state.saved.world.tiles = [];\n    for (let key in state.world.savedTiles) {\n        const tileData = state.world.savedTiles[key];\n        if (!tileData || tileData.level < 0) {\n            continue;\n        }\n        state.saved.world.tiles.push({\n            level: tileData.level,\n            exhaustedDuration: tileData.exhaustedDuration,\n            exhaustCounter: tileData.exhaustCounter,\n            x: tileData.x,\n            y: tileData.y\n        });\n    }\n}\n/**\n * Due to changes in the code or bugs that may be released, sometimes the data\n * in a save file is no longer valid. This method is applied to each save slot\n * on load to correct any issues with the save data found vs what is expected.\n */\nfunction fixSavedData(savedState) {\n    const defaultSavedState = getDefaultSavedState();\n    return {\n        ...defaultSavedState,\n        ...savedState,\n        treasureHunt: {\n            ...defaultSavedState.treasureHunt,\n            ...savedState.treasureHunt,\n        },\n        avatar: {\n            ...defaultSavedState.avatar,\n            ...savedState.avatar,\n        },\n        world: {\n            ...defaultSavedState.world,\n            ...savedState.world,\n        },\n    };\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/saveGame.ts?");

/***/ }),

/***/ "./app/scenes/dungeonScene.ts":
/*!************************************!*\
  !*** ./app/scenes/dungeonScene.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawDungeonScene\": () => (/* binding */ drawDungeonScene),\n/* harmony export */   \"drawDungeonStats\": () => (/* binding */ drawDungeonStats),\n/* harmony export */   \"drawEnterExitButton\": () => (/* binding */ drawEnterExitButton),\n/* harmony export */   \"getEnterExitButton\": () => (/* binding */ getEnterExitButton),\n/* harmony export */   \"handleDungeonClick\": () => (/* binding */ handleDungeonClick),\n/* harmony export */   \"startDungeon\": () => (/* binding */ startDungeon),\n/* harmony export */   \"updateDungeon\": () => (/* binding */ updateDungeon)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_battle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/battle */ \"./app/battle.ts\");\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_hud__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/hud */ \"./app/hud.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_monsters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/monsters */ \"./app/monsters.ts\");\n/* harmony import */ var app_scenes_skillsScene__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/scenes/skillsScene */ \"./app/scenes/skillsScene.ts\");\n/* harmony import */ var app_utils_hud__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/hud */ \"./app/utils/hud.ts\");\n/* harmony import */ var app_handleBackAction__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/handleBackAction */ \"./app/handleBackAction.ts\");\n/* harmony import */ var app_utils_treasureMap__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/utils/treasureMap */ \"./app/utils/treasureMap.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n/* harmony import */ var app_statsBox__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/statsBox */ \"./app/statsBox.ts\");\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_utils_skills__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/utils/skills */ \"./app/utils/skills.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction startDungeon(state, dungeon) {\n    state.dungeon.currentDungeon = dungeon;\n    (0,app_state__WEBPACK_IMPORTED_MODULE_12__.pushScene)(state, 'dungeon');\n    startNewFloor(state);\n}\nfunction startNewFloor(state) {\n    delete state.battle.engagedMonster;\n    delete state.selectedTile;\n    state.world.activeMonsterMarkers = [];\n    const { currentDungeon } = state.dungeon;\n    if (!currentDungeon) {\n        return;\n    }\n    const currentFloor = { tiles: [] };\n    const { allFloors } = currentDungeon;\n    currentDungeon.currentFloor = currentFloor;\n    allFloors.push(currentFloor);\n    const tileThings = [{ type: 'upstairs', frame: app_images__WEBPACK_IMPORTED_MODULE_5__.exitSource }];\n    const numberOfMonsters = app_utils_Random__WEBPACK_IMPORTED_MODULE_15__[\"default\"].integerRange(6, 8);\n    const minPower = currentDungeon.level * .9, maxPower = currentDungeon.level * 1.1;\n    const floorPower = minPower + (maxPower - minPower) * allFloors.length / currentDungeon.numberOfFloors;\n    for (let i = 0; i < numberOfMonsters; i++) {\n        tileThings.push((0,app_monsters__WEBPACK_IMPORTED_MODULE_7__.makeMonster)(state, floorPower - .2 + Math.random() * .4));\n    }\n    if (allFloors.length < currentDungeon.numberOfFloors) {\n        tileThings.push({ type: 'downstairs', frame: app_images__WEBPACK_IMPORTED_MODULE_5__.portalSource });\n    }\n    if (allFloors.length === currentDungeon.numberOfFloors) {\n        tileThings.push((0,app_monsters__WEBPACK_IMPORTED_MODULE_7__.makeBossMonster)(state, floorPower));\n    }\n    // Add at least one power up to each floor, then there is a 20% chance for additional powerups.\n    do {\n        const powerUpValue = (0.8 + Math.random() * 0.4) * floorPower;\n        tileThings.push({ type: 'loot', loot: (0,app_loot__WEBPACK_IMPORTED_MODULE_6__.getWeightedPowerup)(state, powerUpValue) });\n    } while (tileThings.length < 25 && Math.random() < 0.2);\n    const floorCoins = Math.ceil((0.8 + Math.random() * 0.4) * (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_16__.getMoneySkillBonus)(state) * Math.pow(1.1, floorPower) * floorPower * 50);\n    // Intentionally allow more coins than we can hold. Then what the player actually gets will be somewhat random.\n    let coinDrops = (0,app_loot__WEBPACK_IMPORTED_MODULE_6__.generateLootCoins)(floorCoins, 30);\n    // Fewer than 5 coin drops looks too sparse but I don't want to change how generateLootCoins works,\n    // so in this case just add another set of coins worth ~1/2 the original amount. So now such floors\n    // will have higher value of coins even if by some chance they still have a small # of coins.\n    if (coinDrops.length < 5) {\n        coinDrops = coinDrops.concat((0,app_loot__WEBPACK_IMPORTED_MODULE_6__.generateLootCoins)(Math.ceil(floorCoins / 2), 30));\n    }\n    while (tileThings.length < 25 && coinDrops.length) {\n        tileThings.push({ type: 'loot', loot: app_utils_Random__WEBPACK_IMPORTED_MODULE_15__[\"default\"].removeElement(coinDrops), });\n    }\n    let startingTile = null;\n    for (let tileY = 0; tileY < 5; tileY++) {\n        currentFloor.tiles[tileY] = [];\n        for (let tileX = 0; tileX < 5; tileX++) {\n            const realCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_17__.toRealCoords)(state, [tileX, tileY]);\n            const newTile = {\n                x: tileX, y: tileY,\n                level: 0,\n                centerX: realCoords[0] + app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 2,\n                centerY: realCoords[1] + app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength / 2,\n                dungeonContents: app_utils_Random__WEBPACK_IMPORTED_MODULE_15__[\"default\"].removeElement(tileThings),\n                lootMarkers: [],\n                dungeonContentsRevealed: false,\n                guards: 0,\n                journeyDistance: 0,\n                journeyPowerLevel: 0,\n                target: { x: 0, y: 0, w: 0, h: 0 },\n            };\n            const { dungeonContents } = newTile;\n            if (dungeonContents) {\n                const x = newTile.centerX;\n                const y = newTile.centerY;\n                if (dungeonContents.type === 'loot') {\n                    newTile.lootMarkers = [{\n                            loot: dungeonContents.loot,\n                            tile: newTile,\n                            x, y, tx: x, ty: y,\n                        }];\n                }\n                if (dungeonContents.type === 'upstairs') {\n                    currentDungeon.dungeonPosition = [tileX, tileY];\n                    startingTile = newTile;\n                }\n                if (dungeonContents.type === 'monster') {\n                    newTile.monsterMarker = {\n                        type: 'monster',\n                        tile: newTile,\n                        monster: dungeonContents,\n                        x, y,\n                    };\n                    dungeonContents.marker = newTile.monsterMarker;\n                }\n            }\n            currentFloor.tiles[tileY][tileX] = newTile;\n        }\n    }\n    if (startingTile) {\n        revealTile(state, startingTile);\n    }\n}\nfunction updateDungeon(state) {\n    (0,app_loot__WEBPACK_IMPORTED_MODULE_6__.updateLootCollection)(state);\n}\nfunction revealTile(state, tile) {\n    if (tile.lootMarkers.length) {\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.resetLootTotals)(state);\n        setTimeout(function () {\n            for (const lootMarker of tile.lootMarkers) {\n                state.loot.collectingLoot.push(lootMarker);\n            }\n        }, 400);\n    }\n    if (tile.monsterMarker) {\n        state.world.activeMonsterMarkers.push(tile.monsterMarker);\n        for (const neighbor of (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_14__.getAllNeighbors)(state, tile)) {\n            neighbor.guards++;\n        }\n    }\n    (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.regenerateHealth)(state);\n    tile.dungeonContentsRevealed = true;\n    for (const neighbor of getSideNeighbors(state, tile)) {\n        neighbor.dungeonContentsRevealable = true;\n    }\n}\nfunction getSideNeighbors(state, tile) {\n    var _a;\n    const sideNeighbors = [];\n    if (!state.dungeon.currentDungeon) {\n        throw new Error('Current dungeon is not defined');\n    }\n    for (let y = -1; y <= 1; y++) {\n        for (let x = -1; x <= 1; x++) {\n            if (x === 0 && y === 0 || (x !== 0 && y !== 0))\n                continue;\n            const neighbor = (_a = state.dungeon.currentDungeon.currentFloor.tiles[tile.y + y]) === null || _a === void 0 ? void 0 : _a[tile.x + x];\n            if (neighbor) {\n                sideNeighbors.push(neighbor);\n            }\n        }\n    }\n    return sideNeighbors;\n}\nlet lastCanvasSize;\nfunction getDungeonHudButtons() {\n    return [\n        (0,app_battle__WEBPACK_IMPORTED_MODULE_1__.getFightOrFleeButton)(),\n        (0,app_scenes_skillsScene__WEBPACK_IMPORTED_MODULE_8__.getSkillButton)(),\n        (0,app_loot__WEBPACK_IMPORTED_MODULE_6__.getCollectButton)(),\n        enterExitButton,\n    ];\n}\n// Update the targets for skill buttons for the current display settings.\n// This should be called each frame before checking for user clicks or rendering the buttons.\nfunction updateAllDungeonButtonTargets(state) {\n    const { canvas } = state.display;\n    if ((lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.w) === canvas.width && (lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.h) === canvas.height) {\n        return;\n    }\n    lastCanvasSize = { w: canvas.width, h: canvas.height };\n    for (const button of getDungeonHudButtons()) {\n        button.updateTarget(state);\n    }\n}\nfunction handleDungeonClick(state, x, y) {\n    var _a;\n    if (!state.dungeon.currentDungeon) {\n        return false;\n    }\n    updateAllDungeonButtonTargets(state);\n    if ((0,app_hud__WEBPACK_IMPORTED_MODULE_4__.handleHudButtonClick)(state, x, y, getDungeonHudButtons())) {\n        return true;\n    }\n    // Cannot explore tiles while fighting a monster\n    if (state.battle.engagedMonster) {\n        return false;\n    }\n    // Tile interactions\n    const clickedCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_17__.unproject)(state, [x, y]);\n    const clickedGridCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_17__.toGridCoords)(state, clickedCoords);\n    const tile = (_a = state.dungeon.currentDungeon.currentFloor.tiles[clickedGridCoords[1]]) === null || _a === void 0 ? void 0 : _a[clickedGridCoords[0]];\n    if (!tile) {\n        return false;\n    }\n    const canRevealTile = tile.dungeonContentsRevealable && tile.guards <= 0;\n    if (!tile.dungeonContentsRevealed && canRevealTile) {\n        delete state.selectedTile;\n        revealTile(state, tile);\n        return true;\n    }\n    else if (tile === state.selectedTile) {\n        delete state.selectedTile;\n        return true;\n    }\n    else if (tile.dungeonContentsRevealed) {\n        state.selectedTile = tile;\n        return true;\n    }\n    return false;\n}\nfunction drawDungeonScene(context, state) {\n    if (!state.dungeon.currentDungeon) {\n        return;\n    }\n    const { canvas } = state.display;\n    const { selectedTile } = state;\n    const scaleToUse = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_17__.getActualScale)(state);\n    context.fillStyle = context.createPattern(app_images__WEBPACK_IMPORTED_MODULE_5__.darkStoneImage, 'repeat');\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    context.font = 'bold ' + Math.floor(app_gameConstants__WEBPACK_IMPORTED_MODULE_3__.gridLength * scaleToUse) + 'px sans-serif';\n    const border = 3;\n    const allRevealedTiles = [];\n    const currentFloor = state.dungeon.currentDungeon.currentFloor;\n    for (let y = 0; y < currentFloor.tiles.length; y++) {\n        for (let x = 0; x < currentFloor.tiles[y].length; x++) {\n            const tile = currentFloor.tiles[y][x];\n            tile.target = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_17__.getGridRectangle)(state, [tile.x, tile.y]);\n            if (!tile.dungeonContentsRevealed) {\n                const canReveal = tile.dungeonContentsRevealable && tile.guards <= 0;\n                // Top and left edges.\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.fillRectangle)(context, (tile === selectedTile) ? 'red' : '#444', tile.target);\n                // Bottom and right edges\n                context.fillStyle = (tile === selectedTile) ? '#f00' : '#eee';\n                context.fillRect(tile.target.x, tile.target.y, tile.target.w - border, tile.target.h - border);\n                // Background\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.fillRectangle)(context, (tile === selectedTile) ? '#600' : (canReveal ? '#bbb' : '#777'), (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.pad)(tile.target, -border));\n                context.fillStyle = (tile === selectedTile) ? 'red' : '#666';\n                context.fillText('?', tile.target.x + tile.target.w / 2, tile.target.y + tile.target.h / 2);\n                if (tile.guards) {\n                    context.save();\n                    context.globalAlpha *= 0.4;\n                    (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.fillRectangle)(context, 'red', tile.target);\n                    context.restore();\n                }\n                continue;\n            }\n            allRevealedTiles.push(tile);\n            context.save();\n            context.globalAlpha = 0.2;\n            // Top and left edges.\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.fillRectangle)(context, '#aaa', tile.target);\n            // Bottom and right edges.\n            context.fillStyle = '#fff';\n            context.fillRect(tile.target.x, tile.target.y, tile.target.w - border, tile.target.h - border);\n            // Background.\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.fillRectangle)(context, '#aaa', (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.pad)(tile.target, -border));\n            context.restore();\n            if (selectedTile === tile) {\n                context.beginPath();\n                context.rect(tile.target.x, tile.target.y, tile.target.w, tile.target.h);\n                context.rect(tile.target.x + border, tile.target.y + border, tile.target.w - 2 * border, tile.target.h - 2 * border);\n                context.fillStyle = 'green';\n                context.fill('evenodd');\n            }\n        }\n    }\n    for (const tile of allRevealedTiles) {\n        if (!tile.dungeonContents) {\n            continue;\n        }\n        if (tile.dungeonContents.type === 'loot') {\n            // Draw later\n        }\n        else if (tile.dungeonContents.type === 'monster') {\n            // Draw later\n        }\n        else {\n            const frame = tile.dungeonContents.frame;\n            if (!frame) {\n                console.log('Tile with undrawable dungeon contents:', tile);\n                continue;\n            }\n            if (tile === selectedTile) {\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.drawOutlinedImage)(context, 'red', 2, frame, tile.target);\n            }\n            else {\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.drawFrame)(context, frame, tile.target);\n            }\n        }\n    }\n    (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.drawAvatar)(context, state);\n    for (const tile of allRevealedTiles) {\n        if (tile.lootMarkers) {\n            for (const loot of tile.lootMarkers) {\n                (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_9__.drawLootMarker)(context, state, loot, scaleToUse);\n            }\n        }\n        (0,app_monsters__WEBPACK_IMPORTED_MODULE_7__.drawTileMonster)(context, state, tile, scaleToUse);\n    }\n    (0,app_battle__WEBPACK_IMPORTED_MODULE_1__.drawDamageIndicators)(context, state);\n    (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_9__.drawCoinsIndicator)(context, state);\n    (0,app_loot__WEBPACK_IMPORTED_MODULE_6__.drawLootTotals)(context, state, 1000);\n    const hideStatsIn = state.loot.hideStatsAt - state.time;\n    if (hideStatsIn > 0) {\n        context.save();\n        context.globalAlpha = Math.max(0, Math.min(1, hideStatsIn / 1000));\n        (0,app_statsBox__WEBPACK_IMPORTED_MODULE_13__.drawAvatarStats)(context, state);\n        context.restore();\n    }\n    else {\n        (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_9__.drawLifeIndicator)(context, state);\n    }\n    (0,app_statsBox__WEBPACK_IMPORTED_MODULE_13__.drawMonsterStats)(context, state);\n    (0,app_hud__WEBPACK_IMPORTED_MODULE_4__.renderHudButtons)(context, state, getDungeonHudButtons());\n    // Force the stats box to display indefinitely if the tile the avatar is in is selected.\n    if ((selectedTile === null || selectedTile === void 0 ? void 0 : selectedTile.x) === state.dungeon.currentDungeon.dungeonPosition[0]\n        && (selectedTile === null || selectedTile === void 0 ? void 0 : selectedTile.y) === state.dungeon.currentDungeon.dungeonPosition[1]) {\n        state.loot.hideStatsAt = state.time + 1500;\n    }\n}\nconst enterExitButton = {\n    onClick(state) {\n        var _a, _b, _c;\n        const { selectedTile } = state;\n        if (state.currentScene === 'treasureMap') {\n            if ((_a = state.treasureHunt.currentMap) === null || _a === void 0 ? void 0 : _a.dungeon) {\n                (0,app_handleBackAction__WEBPACK_IMPORTED_MODULE_10__.hideTreasureMap)(state);\n                startDungeon(state, state.treasureHunt.currentMap.dungeon);\n                delete state.saved.treasureHunt.currentMap;\n            }\n            return;\n        }\n        if (!selectedTile) {\n            return;\n        }\n        // This is used on the world map for entering a dungeon.\n        if (selectedTile.dungeonMarker) {\n            startDungeon(state, selectedTile.dungeonMarker.dungeon);\n            // The dungeon marker is consumed after entering the dungeon.\n            delete selectedTile.dungeonMarker;\n            return;\n        }\n        if (((_b = selectedTile.dungeonContents) === null || _b === void 0 ? void 0 : _b.type) === 'downstairs') {\n            startNewFloor(state);\n            return;\n        }\n        // The upstairs leave the dungeon entirely no matter what floor you are on.\n        if (((_c = selectedTile.dungeonContents) === null || _c === void 0 ? void 0 : _c.type) === 'upstairs') {\n            (0,app_handleBackAction__WEBPACK_IMPORTED_MODULE_10__.exitDungeon)(state);\n            return;\n        }\n        return;\n    },\n    isVisible(state) {\n        var _a, _b, _c;\n        const { selectedTile } = state;\n        if (state.currentScene === 'treasureMap') {\n            return !!((_a = state.treasureHunt.currentMap) === null || _a === void 0 ? void 0 : _a.dungeon);\n        }\n        if (!selectedTile) {\n            return false;\n        }\n        return !!selectedTile.dungeonMarker\n            || ((_b = selectedTile.dungeonContents) === null || _b === void 0 ? void 0 : _b.type) === 'downstairs'\n            || ((_c = selectedTile.dungeonContents) === null || _c === void 0 ? void 0 : _c.type) === 'upstairs';\n    },\n    render(context, state) {\n        var _a;\n        const { iconSize } = state.display;\n        const { selectedTile } = state;\n        const isEntrance = (state.currentScene === 'treasureMap'\n            || (selectedTile === null || selectedTile === void 0 ? void 0 : selectedTile.dungeonMarker)\n            || ((_a = selectedTile === null || selectedTile === void 0 ? void 0 : selectedTile.dungeonContents) === null || _a === void 0 ? void 0 : _a.type) === 'downstairs');\n        const text = isEntrance ? 'Enter' : 'Exit';\n        context.textBaseline = 'middle';\n        context.textAlign = 'left';\n        context.font = Math.floor(3 * iconSize / 4) + 'px sans-serif';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_5__.exitSource, { ...this.target, w: iconSize, h: iconSize });\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_2__.drawEmbossedText)(context, text, 'gold', 'black', this.target.x + iconSize, this.target.y + iconSize / 2);\n    },\n    updateTarget(state) {\n        const { canvas, iconSize } = state.display;\n        const w = iconSize * 4;\n        // Enter or Exit button is shown in the bottom center of the screen,\n        // just like the collect treasure or upgrade tile button.\n        this.target = {\n            x: Math.floor((canvas.width - w) / 2),\n            y: canvas.height - 10 - iconSize,\n            w,\n            h: iconSize,\n        };\n    },\n    target: { x: 0, y: 0, w: 0, h: 0 }\n};\nfunction getEnterExitButton() {\n    return enterExitButton;\n}\nfunction drawEnterExitButton(context, state) {\n    enterExitButton.render(context, state);\n}\nfunction drawDungeonStats(context, state, dungeon) {\n    const { canvas, iconSize } = state.display;\n    const { selectedTile } = state;\n    if (!dungeon) {\n        return;\n    }\n    let rectangle = selectedTile === null || selectedTile === void 0 ? void 0 : selectedTile.target;\n    if (state.currentScene === 'treasureMap' && state.saved.treasureHunt.currentMap) {\n        const [tx, ty] = (0,app_utils_treasureMap__WEBPACK_IMPORTED_MODULE_11__.getTreasureLocation)(state.saved.treasureHunt.currentMap);\n        rectangle = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_17__.getGridRectangle)(state, [tx, ty]);\n    }\n    // Fallback.\n    if (!rectangle) {\n        rectangle = {\n            x: (canvas.width - iconSize) / 2, y: 2 * iconSize, w: iconSize, h: iconSize,\n        };\n    }\n    const localIconSize = Math.floor(iconSize / 2);\n    const text = 'Lv ' + dungeon.level + ' ' + dungeon.name;\n    const fontSize = Math.floor(3 * localIconSize / 4);\n    context.font = 'bold ' + fontSize + 'px sans-serif';\n    const w = context.measureText(text).width + localIconSize / 2;\n    const h = localIconSize * 1.5;\n    let x = Math.floor(rectangle.x + (rectangle.w - w) / 2);\n    if (x < 10)\n        x = 10;\n    if (x > canvas.width - w - 10)\n        x = canvas.width - w - 10;\n    let y = rectangle.y - h - 5;\n    if (y < 10)\n        y = 10;\n    const padding = Math.floor(localIconSize / 4);\n    context.fillStyle = '#BBB';\n    context.fillRect(x, y, w, h);\n    context.fillStyle = '#FFF';\n    context.fillRect(x + 1, y + 1, w - 2, h - 2);\n    context.fillStyle = '#222';\n    context.fillRect(x + 3, y + 3, w - 6, h - 6);\n    context.textBaseline = 'middle';\n    context.textAlign = 'left';\n    context.fillStyle = '#C00';\n    context.fillText(text, x + padding, y + padding + localIconSize / 2);\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/scenes/dungeonScene.ts?");

/***/ }),

/***/ "./app/scenes/mapScene.ts":
/*!********************************!*\
  !*** ./app/scenes/mapScene.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawMapScene\": () => (/* binding */ drawMapScene),\n/* harmony export */   \"handleMapClick\": () => (/* binding */ handleMapClick),\n/* harmony export */   \"levelColors\": () => (/* binding */ levelColors),\n/* harmony export */   \"updateMap\": () => (/* binding */ updateMap)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_battle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/battle */ \"./app/battle.ts\");\n/* harmony import */ var app_context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/context */ \"./app/context.ts\");\n/* harmony import */ var app_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/dom */ \"./app/dom.ts\");\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_gems__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/gems */ \"./app/gems.ts\");\n/* harmony import */ var app_hud__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/hud */ \"./app/hud.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_journeyMode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/journeyMode */ \"./app/journeyMode.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_monsters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/monsters */ \"./app/monsters.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/scenes/dungeonScene */ \"./app/scenes/dungeonScene.ts\");\n/* harmony import */ var app_scenes_skillsScene__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/scenes/skillsScene */ \"./app/scenes/skillsScene.ts\");\n/* harmony import */ var app_scenes_treasureMapScene__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/scenes/treasureMapScene */ \"./app/scenes/treasureMapScene.ts\");\n/* harmony import */ var app_statsBox__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/statsBox */ \"./app/statsBox.ts\");\n/* harmony import */ var app_utils_hud__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! app/utils/hud */ \"./app/utils/hud.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n/* harmony import */ var app_utils_skills__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! app/utils/skills */ \"./app/utils/skills.ts\");\n/* harmony import */ var app_utils_updateGems__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! app/utils/updateGems */ \"./app/utils/updateGems.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst levelColors = [\n    app_images__WEBPACK_IMPORTED_MODULE_8__.shallowSource,\n    app_images__WEBPACK_IMPORTED_MODULE_8__.sandSource,\n    app_images__WEBPACK_IMPORTED_MODULE_8__.dirtSource,\n    app_images__WEBPACK_IMPORTED_MODULE_8__.grassSource,\n    app_images__WEBPACK_IMPORTED_MODULE_8__.forestSource,\n    app_images__WEBPACK_IMPORTED_MODULE_8__.hillSource,\n    app_images__WEBPACK_IMPORTED_MODULE_8__.mountainSource,\n    app_images__WEBPACK_IMPORTED_MODULE_8__.iceSource,\n];\nif (levelColors.length !== app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.maxTileLevel + 1) {\n    console.error(`Incorrect number of tiles found, expected ${app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.maxTileLevel + 1} found ${levelColors.length}`, levelColors.length);\n}\nfunction updateMap(state) {\n    (0,app_loot__WEBPACK_IMPORTED_MODULE_10__.updateMapLoot)(state);\n    (0,app_utils_updateGems__WEBPACK_IMPORTED_MODULE_20__.updateGems)(state);\n}\nfunction getMapHudButtons() {\n    return [\n        (0,app_battle__WEBPACK_IMPORTED_MODULE_1__.getFightOrFleeButton)(),\n        (0,app_scenes_skillsScene__WEBPACK_IMPORTED_MODULE_14__.getSkillButton)(),\n        (0,app_loot__WEBPACK_IMPORTED_MODULE_10__.getCollectButton)(),\n        (0,app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_13__.getEnterExitButton)(),\n        (0,app_scenes_treasureMapScene__WEBPACK_IMPORTED_MODULE_15__.getTreasureMapButton)(),\n        (0,app_journeyMode__WEBPACK_IMPORTED_MODULE_9__.getJourneyButton)(),\n        upgradeTileButton,\n    ];\n}\n// Update the targets for skill buttons for the current display settings.\n// This should be called each frame before checking for user clicks or rendering the buttons.\nlet lastCanvasSize;\nfunction updateAllMapButtonTargets(state) {\n    const { canvas } = state.display;\n    if ((lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.w) === canvas.width && (lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.h) === canvas.height) {\n        return;\n    }\n    lastCanvasSize = { w: canvas.width, h: canvas.height };\n    for (const button of getMapHudButtons()) {\n        button.updateTarget(state);\n    }\n}\nfunction handleMapClick(state, x, y) {\n    if (state.globalPosition.isFastMode || state.globalPosition.isFixingGPS) {\n        return;\n    }\n    updateAllMapButtonTargets(state);\n    if ((0,app_hud__WEBPACK_IMPORTED_MODULE_7__.handleHudButtonClick)(state, x, y, getMapHudButtons())) {\n        return;\n    }\n    const clickedCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.unproject)(state, [x, y]);\n    const clickedGridCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.toGridCoords)(state, clickedCoords);\n    if ((0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.isTileExplored)(state, clickedGridCoords) && !state.battle.engagedMonster) {\n        const clickedTile = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.getTileData)(state, clickedGridCoords);\n        if (state.selectedTile === clickedTile) {\n            delete state.selectedTile;\n        }\n        else if (state.world.selectableTiles.has(clickedTile)) {\n            if (state.currentScene === 'map') {\n                state.selectedTile = clickedTile;\n            }\n            else if (state.currentScene === 'journey' && (clickedTile.monsterMarker || clickedTile.dungeonMarker)) {\n                state.selectedTile = clickedTile;\n            }\n        }\n    }\n}\nfunction drawMapScene(context, state) {\n    var _a, _b;\n    const { canvas, iconSize } = state.display;\n    // Draws the background as well as all markers (loot, monsters + dungeons).\n    drawGrid(context, state);\n    // Draw the collection radius ring, but only if we know the current position and the player\n    // is not currently collecting loot or the player is auto-collecting loot in fast mode.\n    if (state.world.currentPosition && (state.globalPosition.isFastMode || state.loot.collectingLoot.length === 0)) {\n        //\n        const point = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.project)(state, state.world.currentPosition);\n        context.save();\n        context.globalAlpha = .3;\n        context.strokeStyle = 'gold';\n        context.lineWidth = 4;\n        context.beginPath();\n        context.arc(point[0], point[1], (0,app_loot__WEBPACK_IMPORTED_MODULE_10__.getCollectionRadius)(state) * (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.getActualScale)(state), 0, 2 * Math.PI);\n        context.stroke();\n        context.restore();\n    }\n    (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.drawAvatar)(context, state);\n    (0,app_battle__WEBPACK_IMPORTED_MODULE_1__.drawDamageIndicators)(context, state);\n    const { selectedTile } = state;\n    if (selectedTile && !selectedTile.monsterMarker && !selectedTile.dungeonMarker) {\n        const rectangle = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.getGridRectangle)(state, [selectedTile.x, selectedTile.y]);\n        const canUpgrade = canUpgradeTile(state, selectedTile);\n        context.save();\n        context.globalAlpha *= 0.6;\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawRectangleFrame)(context, 'white', 4, (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.pad)(rectangle, 1));\n        context.restore();\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawRectangleFrame)(context, canUpgrade ? 'green' : 'red', 2, rectangle);\n    }\n    const hideStatsIn = state.loot.hideStatsAt - state.time;\n    if (!state.globalPosition.isFastMode && !state.globalPosition.isFixingGPS && hideStatsIn > 0) {\n        context.save();\n        context.globalAlpha = Math.max(0, Math.min(1, hideStatsIn / 1000));\n        (0,app_statsBox__WEBPACK_IMPORTED_MODULE_16__.drawAvatarStats)(context, state);\n        context.restore();\n    }\n    else {\n        (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_17__.drawLifeIndicator)(context, state);\n    }\n    // Force showing stats if the avatar is in the selected tile.\n    if ((selectedTile === null || selectedTile === void 0 ? void 0 : selectedTile.x) === ((_a = state.world.currentGridCoords) === null || _a === void 0 ? void 0 : _a[0]) && (selectedTile === null || selectedTile === void 0 ? void 0 : selectedTile.y) === ((_b = state.world.currentGridCoords) === null || _b === void 0 ? void 0 : _b[1])) {\n        state.loot.hideStatsAt = state.time + 1500;\n    }\n    (0,app_statsBox__WEBPACK_IMPORTED_MODULE_16__.drawMonsterStats)(context, state);\n    if (selectedTile === null || selectedTile === void 0 ? void 0 : selectedTile.dungeonMarker) {\n        (0,app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_13__.drawDungeonStats)(context, state, selectedTile.dungeonMarker.dungeon);\n    }\n    if (state.globalPosition.isFixingGPS) {\n        const fontSize = Math.floor(3 * iconSize / 4);\n        context.font = fontSize + 'px sans-serif';\n        context.textAlign = 'center';\n        context.textBaseline = 'bottom';\n        let text = 'Updating';\n        for (let i = 0; i < (state.globalPosition.endFixingGPSTime - state.time) / 1000; i++) {\n            text = '-' + text + '-';\n        }\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawEmbossedText)(context, text, 'gold', 'black', canvas.width / 2, canvas.height - 10);\n    }\n    else if (state.globalPosition.isFastMode) {\n        const fontSize = Math.floor(3 * iconSize / 4);\n        context.font = fontSize + 'px sans-serif';\n        context.textAlign = 'center';\n        context.textBaseline = 'bottom';\n        let text = 'Fast Mode';\n        for (let i = 0; i < (state.globalPosition.endFastModeTime - state.time) / 2000; i++) {\n            text = '-' + text + '-';\n        }\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawEmbossedText)(context, text, 'gold', 'black', canvas.width / 2, canvas.height - 10);\n    }\n    else {\n        (0,app_gems__WEBPACK_IMPORTED_MODULE_6__.drawGemIndicators)(context, state);\n        updateAllMapButtonTargets(state);\n        (0,app_hud__WEBPACK_IMPORTED_MODULE_7__.renderHudButtons)(context, state, getMapHudButtons());\n    }\n    (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_17__.drawCoinsIndicator)(context, state);\n    (0,app_loot__WEBPACK_IMPORTED_MODULE_10__.drawLootTotals)(context, state);\n}\nconst upgradeTileButton = {\n    onClick(state) {\n        if (!state.selectedTile) {\n            throw new Error('Expected state.selectedTile to be defined');\n        }\n        upgradeTile(state, state.selectedTile);\n    },\n    isDisabled(state) {\n        const { selectedTile } = state;\n        if (!selectedTile) {\n            return true;\n        }\n        const cost = costToUpgrade(state, selectedTile);\n        return !canUpgradeTile(state, selectedTile) || cost > state.saved.coins;\n    },\n    isVisible(state) {\n        const { selectedTile } = state;\n        if (!selectedTile) {\n            return false;\n        }\n        if (selectedTile.monsterMarker || selectedTile.dungeonMarker) {\n            return false;\n        }\n        return true;\n    },\n    render(context, state) {\n        const { iconSize } = state.display;\n        const { selectedTile } = state;\n        if (!selectedTile) {\n            return;\n        }\n        const canUpgrade = canUpgradeTile(state, selectedTile);\n        const cost = costToUpgrade(state, selectedTile);\n        const canAfford = cost <= state.saved.coins;\n        context.save();\n        if (!canAfford || !canUpgrade) {\n            context.globalAlpha = .5;\n        }\n        context.textBaseline = 'middle';\n        context.textAlign = 'left';\n        context.font = Math.floor(3 * iconSize / 4) + 'px sans-serif';\n        var text = canUpgrade ? '-' + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_18__.abbreviateNumber)(cost) : '---';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawSolidTintedImage)(context, (canAfford && canUpgrade) ? 'green' : 'red', app_images__WEBPACK_IMPORTED_MODULE_8__.upArrows, { ...this.target, w: iconSize, h: iconSize });\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawEmbossedText)(context, text, canAfford ? 'white' : 'red', 'black', this.target.x + iconSize, this.target.y + iconSize / 2);\n        context.restore();\n    },\n    updateTarget(state) {\n        const { canvas, iconSize } = state.display;\n        const w = iconSize;\n        // Bottom center of the screen.\n        this.target = {\n            x: Math.floor((canvas.width - w) / 2),\n            y: canvas.height - 10 - iconSize,\n            w,\n            h: iconSize\n        };\n    },\n    target: { x: 0, y: 0, w: 0, h: 0 }\n};\nfunction upgradeTile(state, tile) {\n    var _a;\n    const cost = costToUpgrade(state, tile);\n    if (!cost || state.saved.coins < cost) {\n        return;\n    }\n    tile.level++;\n    delete tile.canvas;\n    if (tile.neighbors) {\n        for (const neighbor of tile.neighbors) {\n            delete neighbor.canvas;\n        }\n    }\n    state.saved.coins -= cost;\n    for (var i = 0; i <= tile.level; i++) {\n        state.world.levelSums[i] = ((_a = state.world.levelSums[i]) !== null && _a !== void 0 ? _a : 0) + 1;\n    }\n    tile.exhaustedDuration = 0;\n    (0,app_loot__WEBPACK_IMPORTED_MODULE_10__.checkToGenerateLootForTile)(state, tile);\n    (0,app_monsters__WEBPACK_IMPORTED_MODULE_11__.checkToGenerateMonster)(state, tile, .5);\n    delete state.selectedTile;\n    (0,app_saveGame__WEBPACK_IMPORTED_MODULE_12__.saveGame)(state);\n}\nfunction canUpgradeTile(state, tile) {\n    var _a;\n    if (!tile.neighbors) {\n        return false;\n    }\n    let neighborSum = 0;\n    let numNeighbors = 0;\n    for (let i = 0; i < tile.neighbors.length; i++) {\n        if (tile === tile.neighbors[i] || !tile.neighbors[i]) {\n            continue;\n        }\n        numNeighbors++;\n        neighborSum += (_a = tile.neighbors[i].level) !== null && _a !== void 0 ? _a : 0;\n    }\n    return tile.level >= 0 && (numNeighbors >= 8) && (neighborSum >= (8 * tile.level));\n}\nfunction costToUpgrade(state, tile) {\n    var _a;\n    if (tile.level >= app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.maxTileLevel) {\n        return -1;\n    }\n    let cost = 5;\n    for (let i = 1; i <= tile.level + 1; i++) {\n        cost += 2 * (((_a = state.world.levelSums[i]) !== null && _a !== void 0 ? _a : 0) + 1) * Math.pow(10, i - 1);\n    }\n    return Math.floor(cost * (1 - (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_19__.getSkillValue)(state, 'explorer')));\n}\nfunction createOrUpdateTileCanvas(state, tile, scaleToUse) {\n    if (!tile.neighbors) {\n        return;\n    }\n    tile.scale = scaleToUse;\n    const neighbors = tile.neighbors;\n    const rectangle = tile.target;\n    const neighborLevel = (dx, dy) => {\n        var _a, _b;\n        return (_b = (_a = neighbors[(dx + 1) + 3 * (dy + 1)]) === null || _a === void 0 ? void 0 : _a.level) !== null && _b !== void 0 ? _b : -1;\n    };\n    if (!tile.canvas) {\n        tile.canvas = (0,app_dom__WEBPACK_IMPORTED_MODULE_3__.createCanvas)(rectangle.w, rectangle.h);\n    }\n    else {\n        tile.canvas.width = rectangle.w;\n        tile.canvas.height = rectangle.h;\n    }\n    const tileContext = tile.canvas.getContext('2d');\n    tileContext.imageSmoothingEnabled = false;\n    // Draw the current tile's pattern to all four corners\n    const w = rectangle.w, halfW = Math.floor(rectangle.w / 2);\n    const h = rectangle.h, halfH = Math.floor(rectangle.h / 2);\n    if (tile.level >= 0) {\n        const patternSource = levelColors[tile.level];\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawFrame)(tileContext, patternSource, { x: 0, y: 0, w: halfW, h: halfH });\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawFrame)(tileContext, patternSource, { x: halfW, y: 0, w: w - halfW, h: halfH });\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawFrame)(tileContext, patternSource, { x: 0, y: halfH, w: halfW, h: h - halfH });\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawFrame)(tileContext, patternSource, { x: halfW, y: halfH, w: w - halfW, h: h - halfH });\n    }\n    for (let i = tile.level + 1; i < levelColors.length; i++) {\n        // top left\n        const patternSource = levelColors[i];\n        let cornerSource = { ...patternSource };\n        if (neighborLevel(0, -1) >= i && neighborLevel(-1, 0) >= i) {\n            // top and left filled in\n            cornerSource.x += 34;\n            cornerSource.y -= 17;\n        }\n        else if (neighborLevel(0, -1) >= i) {\n            // only top filled in\n            cornerSource.y += 17;\n        }\n        else if (neighborLevel(-1, 0) >= i) {\n            // only left filled in\n            cornerSource.x += 17;\n        }\n        else if (neighborLevel(-1, -1) >= i) {\n            // only corner filled in\n            cornerSource.x += 17;\n            cornerSource.y += 17;\n        }\n        else {\n            cornerSource = null;\n        }\n        /*if (i === 0 && tile === state.selectedTile) {\n            console.log('T ', neighborLevel(0, -1));\n            console.log('TL', neighborLevel(-1, -1));\n            console.log('L ', neighborLevel(-1, 0));\n            console.log(patternSource.x, patternSource.y, cornerSource?.x, cornerSource?.y);\n        }*/\n        if (cornerSource) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawFrame)(tileContext, cornerSource, { x: 0, y: 0, w: halfW, h: halfH });\n        }\n        // top right\n        cornerSource = { ...patternSource };\n        if (neighborLevel(0, -1) >= i && neighborLevel(1, 0) >= i) {\n            // top and left filled in\n            cornerSource.x += 51;\n            cornerSource.y -= 17;\n        }\n        else if (neighborLevel(0, -1) >= i) {\n            // only top filled in\n            cornerSource.y += 17;\n        }\n        else if (neighborLevel(1, 0) >= i) {\n            // only left filled in\n            cornerSource.x -= 17;\n        }\n        else if (neighborLevel(1, -1) >= i) {\n            // only corner filled in\n            cornerSource.x -= 17;\n            cornerSource.y += 17;\n        }\n        else {\n            cornerSource = null;\n        }\n        if (cornerSource) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawFrame)(tileContext, cornerSource, { x: halfW, y: 0, w: w - halfW, h: halfH });\n        }\n        // bottom left\n        cornerSource = { ...patternSource };\n        if (neighborLevel(0, 1) >= i && neighborLevel(-1, 0) >= i) {\n            // top and left filled in\n            cornerSource.x += 34;\n        }\n        else if (neighborLevel(0, 1) >= i) {\n            // only top filled in\n            cornerSource.y -= 17;\n        }\n        else if (neighborLevel(-1, 0) >= i) {\n            // only left filled in\n            cornerSource.x += 17;\n        }\n        else if (neighborLevel(-1, 1) >= i) {\n            // only corner filled in\n            cornerSource.x += 17;\n            cornerSource.y -= 17;\n        }\n        else {\n            cornerSource = null;\n        }\n        if (cornerSource) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawFrame)(tileContext, cornerSource, { x: 0, y: halfH, w: halfW, h: h - halfH });\n        }\n        // bottom right\n        cornerSource = { ...patternSource };\n        if (neighborLevel(0, 1) >= i && neighborLevel(1, 0) >= i) {\n            // top and left filled in\n            cornerSource.x += 51;\n        }\n        else if (neighborLevel(0, 1) >= i) {\n            // only top filled in\n            cornerSource.y -= 17;\n        }\n        else if (neighborLevel(1, 0) >= i) {\n            // only left filled in\n            cornerSource.x -= 17;\n        }\n        else if (neighborLevel(1, 1) >= i) {\n            // only corner filled in\n            cornerSource.x -= 17;\n            cornerSource.y -= 17;\n        }\n        else {\n            cornerSource = null;\n        }\n        if (cornerSource) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawFrame)(tileContext, cornerSource, { x: halfW, y: halfH, w: w - halfW, h: h - halfH });\n        }\n    }\n}\nfunction drawGrid(context, state) {\n    const { canvas, iconSize } = state.display;\n    const scaleToUse = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.getActualScale)(state);\n    const canvasRectangle = { x: 0, y: 0, w: canvas.width, h: canvas.height };\n    context.fillStyle = 'black';\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    const { currentGridCoords, currentPosition } = state.world;\n    if (!currentGridCoords || !currentPosition) {\n        return;\n    }\n    const gradientLength = 0.3 * scaleToUse * app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.gridLength;\n    const origin = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.getOrigin)(state);\n    // Top left corner of what will be displayed on the screen in canvas coordinates.\n    const topLeftCorner = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.project)(state, [currentPosition[0] - 4 * app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.gridLength, currentPosition[1] - 4 * app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.gridLength]);\n    const gridSize = Math.round(app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.gridLength * scaleToUse);\n    let x = Math.max(-gradientLength / 2, topLeftCorner[0]);\n    let y = Math.max(-gradientLength / 2, topLeftCorner[1]);\n    // The portion of the canvas that will be visible and drawn to.\n    const visibleRectangle = {\n        x, y,\n        w: Math.min(canvas.width + gradientLength / 2, topLeftCorner[0] + 8 * gridSize) - x,\n        h: Math.min(canvas.height + gradientLength / 2, topLeftCorner[1] + 8 * gridSize) - y,\n    };\n    const isJourneyMode = state.currentScene === 'journey' || state.currentScene === 'voyage';\n    // The ocean background is not used in journey mode.\n    if (state.currentScene !== 'journey') {\n        context.save();\n        context.imageSmoothingEnabled = false;\n        const oceanScale = gridSize / app_images__WEBPACK_IMPORTED_MODULE_8__.oceanTile.width;\n        context.scale(oceanScale, oceanScale);\n        const dx = (state.time / 15) / 1000;\n        const dy = (state.time / 20) / 1000;\n        //  + origin[1] * scaleToUse\n        const oceanX = (((dx * app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.gridLength + canvas.width / 2 / scaleToUse - origin[0]) % app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.gridLength) / oceanScale * scaleToUse);\n        const oceanY = (((dy * app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.gridLength + canvas.height / 2 / scaleToUse - origin[1]) % app_gameConstants__WEBPACK_IMPORTED_MODULE_5__.gridLength) / oceanScale * scaleToUse);\n        context.translate(oceanX, oceanY);\n        const oceanPattern = context.createPattern(app_images__WEBPACK_IMPORTED_MODULE_8__.oceanTile, 'repeat');\n        context.fillStyle = oceanPattern;\n        context.fillRect(-oceanX - 2, -oceanY - 2, canvas.width + 4, canvas.height + 4);\n        context.restore();\n    }\n    const visibleTiles = new Set();\n    let draws = 0;\n    for (const mapTile of state.world.activeTiles) {\n        const rectangle = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_21__.getGridRectangle)(state, [mapTile.x, mapTile.y]);\n        mapTile.target = rectangle;\n        if (!(0,app_utils_index__WEBPACK_IMPORTED_MODULE_18__.rectanglesOverlap)(rectangle, canvasRectangle)) {\n            continue;\n        }\n        // Don't draw unexplored tiles.\n        if (isJourneyMode && !mapTile.isExplored) {\n            continue;\n        }\n        visibleTiles.add(mapTile);\n        draws++;\n        if (!mapTile.canvas || mapTile.scale !== scaleToUse) {\n            createOrUpdateTileCanvas(state, mapTile, scaleToUse);\n        }\n        if (!mapTile.canvas) {\n            continue;\n        }\n        context.drawImage(mapTile.canvas, 0, 0, mapTile.canvas.width, mapTile.canvas.height, rectangle.x, rectangle.y, rectangle.w, rectangle.h);\n        if (mapTile.exhaustedDuration && mapTile.exhaustCounter !== undefined\n            && state.currentScene !== 'journey' && state.currentScene !== 'voyage') {\n            const exhaustRadius = Math.min(rectangle.w / 2, rectangle.h / 2) - (1 + mapTile.level) * Math.round(rectangle.w / 30);\n            context.save();\n            const percent = (mapTile.exhaustedDuration - mapTile.exhaustCounter) / mapTile.exhaustedDuration;\n            context.globalAlpha = .25;\n            context.fillStyle = 'black';\n            context.lineWidth = 3;\n            context.strokeStyle = 'white';\n            context.beginPath();\n            if (percent < 1)\n                context.moveTo(rectangle.x + rectangle.w / 2, rectangle.y + rectangle.h / 2);\n            context.arc(rectangle.x + rectangle.w / 2, rectangle.y + rectangle.h / 2, exhaustRadius, -Math.PI / 2 - percent * 2 * Math.PI, -Math.PI / 2);\n            if (percent < 1)\n                context.closePath();\n            context.stroke();\n            context.fill();\n            context.restore();\n        }\n    }\n    // Draw coins first\n    for (const mapTile of state.world.activeTiles) {\n        if (!visibleTiles.has(mapTile)) {\n            continue;\n        }\n        for (const loot of mapTile.lootMarkers) {\n            draws++;\n            if (loot !== mapTile.powerupMarker && loot !== mapTile.gemMarker) {\n                (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_17__.drawLootMarker)(context, state, loot, scaleToUse);\n            }\n        }\n    }\n    // Powerups + Gems are on top of coins so they don't get obscured.\n    for (const mapTile of state.world.activeTiles) {\n        if (!visibleTiles.has(mapTile)) {\n            continue;\n        }\n        if (mapTile.powerupMarker) {\n            (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_17__.drawLootMarker)(context, state, mapTile.powerupMarker, scaleToUse);\n        }\n        if (mapTile.gemMarker) {\n            (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_17__.drawLootMarker)(context, state, mapTile.gemMarker, scaleToUse);\n        }\n    }\n    // Draw dungeons + monsters last.\n    for (const mapTile of state.world.activeTiles) {\n        if (!visibleTiles.has(mapTile)) {\n            continue;\n        }\n        if (mapTile.dungeonMarker) {\n            const frame = mapTile.dungeonMarker.dungeon.frame;\n            const target = {\n                x: mapTile.target.x + mapTile.target.w / 6,\n                y: mapTile.target.y + mapTile.target.h / 6,\n                w: 2 * mapTile.target.w / 3,\n                h: 2 * mapTile.target.w / 3,\n            };\n            draws++;\n            if (mapTile === state.selectedTile) {\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawOutlinedImage)(context, 'red', 2, frame, target);\n            }\n            else {\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawFrame)(context, frame, target);\n            }\n        }\n        (0,app_monsters__WEBPACK_IMPORTED_MODULE_11__.drawTileMonster)(context, state, mapTile, scaleToUse);\n    }\n    if (visibleRectangle.x + gradientLength > 0) {\n        const gradient = context.createLinearGradient(visibleRectangle.x, 0, visibleRectangle.x + gradientLength, 0);\n        gradient.addColorStop(0, 'black');\n        gradient.addColorStop(1, 'transparent');\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, visibleRectangle.x + gradientLength, canvas.height);\n    }\n    if (visibleRectangle.y + gradientLength > 0) {\n        const gradient = context.createLinearGradient(0, visibleRectangle.y, 0, visibleRectangle.y + gradientLength);\n        gradient.addColorStop(0, 'black');\n        gradient.addColorStop(1, 'transparent');\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, canvas.width, visibleRectangle.y + gradientLength);\n    }\n    if (visibleRectangle.x + visibleRectangle.w - gradientLength < canvas.width) {\n        const left = visibleRectangle.x + visibleRectangle.w - gradientLength;\n        const gradient = context.createLinearGradient(left, 0, visibleRectangle.x + visibleRectangle.w, 0);\n        gradient.addColorStop(0, 'transparent');\n        gradient.addColorStop(1, 'black');\n        context.fillStyle = gradient;\n        context.fillRect(left, 0, canvas.width - left, canvas.height);\n    }\n    if (visibleRectangle.y + gradientLength > 0) {\n        const top = visibleRectangle.y + visibleRectangle.h - gradientLength;\n        const gradient = context.createLinearGradient(0, top, 0, visibleRectangle.y + visibleRectangle.h);\n        gradient.addColorStop(0, 'transparent');\n        gradient.addColorStop(1, 'black');\n        context.fillStyle = gradient;\n        context.fillRect(0, top, canvas.width, canvas.height - top);\n    }\n    if (app_context__WEBPACK_IMPORTED_MODULE_2__.isDebugMode) {\n        context.font = Math.round(iconSize / 2) + 'px sans-serif';\n        context.textAlign = 'center';\n        context.textBaseline = 'top';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_4__.drawEmbossedText)(context, `${draws}`, 'white', 'black', canvas.width / 2, 5);\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/scenes/mapScene.ts?");

/***/ }),

/***/ "./app/scenes/skillsScene.ts":
/*!***********************************!*\
  !*** ./app/scenes/skillsScene.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawSkillsScene\": () => (/* binding */ drawSkillsScene),\n/* harmony export */   \"getSkillButton\": () => (/* binding */ getSkillButton),\n/* harmony export */   \"handleSkillsClick\": () => (/* binding */ handleSkillsClick)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_handleBackAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/handleBackAction */ \"./app/handleBackAction.ts\");\n/* harmony import */ var app_hud__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/hud */ \"./app/hud.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n/* harmony import */ var app_utils_skills__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/skills */ \"./app/utils/skills.ts\");\n\n\n\n\n\n\n\n\nfunction getSkillDisplayValues(state) {\n    const { canvas, iconSize } = state.display;\n    const centerX = Math.round(canvas.width / 2);\n    const centerY = Math.round((canvas.height - iconSize) / 2);\n    const padding = 5;\n    const skillSize = Math.round(Math.min((canvas.width - 8 * padding) / 7, (canvas.height - iconSize - 8 * padding) / 7) / 2) * 2;\n    const skillSpacing = skillSize + padding;\n    const border = 3;\n    return {\n        canvas,\n        w: canvas.width,\n        h: canvas.height,\n        border,\n        centerX,\n        centerY,\n        skillSize,\n        skillSpacing,\n        iconSize,\n        padding,\n    };\n}\nfunction drawSkillsScene(context, state) {\n    const { canvas, centerX, centerY, skillSize, skillSpacing, } = getSkillDisplayValues(state);\n    // Draw background\n    context.fillStyle = context.createPattern(app_images__WEBPACK_IMPORTED_MODULE_4__.darkStoneImage, 'repeat');\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    // Updated + Draw hud buttons\n    updateAllSkillButtonTargets(state);\n    (0,app_hud__WEBPACK_IMPORTED_MODULE_3__.renderHudButtons)(context, state, getSkillHudButtons(state));\n    const { selectedSkill } = state.avatar;\n    const selectedSkillType = selectedSkill === null || selectedSkill === void 0 ? void 0 : selectedSkill.affinity;\n    const selectedSkillCost = selectedSkill ? (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillCost)(state, selectedSkill) : 0;\n    const netPoints = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getAvailableSkillPoints)(state) - selectedSkillCost;\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.outlinedMoneySource, { x: centerX - skillSpacing, y: centerY + skillSpacing * 3 - skillSize / 2, w: skillSize, h: skillSize });\n    context.font = Math.floor(skillSize / 3) + 'px sans-serif';\n    context.textBaseline = 'middle';\n    context.textAlign = 'left';\n    let bonus = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getMoneySkillBonus)(state) - 1;\n    let color = 'green';\n    if (selectedSkillType === 'health') {\n        bonus -= selectedSkillCost / 100;\n        color = 'red';\n    }\n    else if (selectedSkillType === 'money') {\n        bonus += selectedSkillCost / 100;\n        color = '#0F0';\n    }\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, (bonus >= 0 ? '+' : '') + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_6__.percentText)(bonus, 0), color, 'white', centerX, centerY + skillSpacing * 3);\n    bonus = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getHealthSkillBonus)(state) - 1;\n    color = 'green';\n    if (selectedSkillType === 'money') {\n        bonus -= selectedSkillCost / 100;\n        color = 'red';\n    }\n    else if (selectedSkillType === 'health') {\n        bonus += selectedSkillCost / 100;\n        color = '#0F0';\n    }\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.heartSource, { x: centerX - skillSpacing, y: centerY - skillSpacing * 3 - skillSize / 2, w: skillSize, h: skillSize });\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, (bonus >= 0 ? '+' : '') + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_6__.percentText)(bonus, 0), color, 'white', centerX, centerY - skillSpacing * 3);\n    bonus = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getAttackSkillBonus)(state) - 1;\n    color = 'green';\n    if (selectedSkillType === 'defense') {\n        bonus -= selectedSkillCost / 100;\n        color = 'red';\n    }\n    else if (selectedSkillType === 'attack') {\n        bonus += selectedSkillCost / 100;\n        color = '#0F0';\n    }\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.swordSource, { x: centerX - 3 * skillSpacing - skillSize / 2, y: centerY - skillSpacing, w: skillSize, h: skillSize });\n    context.textBaseline = 'top';\n    context.textAlign = 'right';\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, (bonus >= 0 ? '+' : '') + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_6__.percentText)(bonus, 0), color, 'white', centerX - skillSpacing * 3 + skillSize / 2, centerY);\n    bonus = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getDefenseSkillBonus)(state) - 1;\n    color = 'green';\n    if (selectedSkillType === 'attack') {\n        bonus -= selectedSkillCost / 100;\n        color = 'red';\n    }\n    else if (selectedSkillType === 'defense') {\n        bonus += selectedSkillCost / 100;\n        color = '#0F0';\n    }\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.shieldSource, { x: centerX + 3 * skillSpacing - skillSize / 2, y: centerY - skillSpacing, w: skillSize, h: skillSize });\n    context.textAlign = 'left';\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, (bonus >= 0 ? '+' : '') + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_6__.percentText)(bonus, 0), color, 'white', centerX + skillSpacing * 3 - skillSize / 2, centerY);\n    color = netPoints >= 0 ? 'green' : 'red';\n    context.textBaseline = 'middle';\n    context.textAlign = 'center';\n    context.font = 'bold ' + Math.floor(skillSize / 2) + 'px sans-serif';\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedText)(context, netPoints >= 0 ? `${netPoints}` : '- -', color, 'white', 1, centerX, centerY);\n    if (selectedSkill) {\n        const skillKey = selectedSkill.key;\n        const skillLevel = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillLevel)(state, skillKey);\n        const fontSize = Math.floor(skillSize / 3);\n        const currentValue = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillValue)(state, skillKey, skillLevel);\n        const newValue = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillValue)(state, skillKey, skillLevel + 1);\n        let parts, leftDescription, formattedValue, formattedNewValue, rightDescription;\n        if (selectedSkill.description.indexOf('%') >= 0) {\n            parts = selectedSkill.description.split('%');\n            leftDescription = parts[0];\n            formattedValue = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_6__.percentText)(currentValue, 1);\n            formattedNewValue = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_6__.percentText)(newValue, 1);\n            rightDescription = parts[1];\n        }\n        else {\n            parts = selectedSkill.description.split('#');\n            leftDescription = parts[0];\n            formattedValue = '+' + currentValue;\n            formattedNewValue = '+' + newValue;\n            rightDescription = parts[1];\n        }\n        if (leftDescription.length) {\n            leftDescription = leftDescription.substring(0, leftDescription.length);\n        }\n        rightDescription = rightDescription.substring(1);\n        context.font = fontSize + 'px sans-serif';\n        const width = Math.max(context.measureText(leftDescription).width, context.measureText(rightDescription).width) + 10;\n        let height = Math.ceil(fontSize * 3.2 + 25);\n        if (leftDescription) {\n            height += fontSize + 5;\n        }\n        let top = 10;\n        const left = 10;\n        const titleHeight = 10 + fontSize;\n        // Box\n        context.fillStyle = '#EEE';\n        context.fillRect(left - 2, top - 2, width + 4, height + 4);\n        context.fillStyle = '#666';\n        context.fillRect(left, top + titleHeight, width, height - titleHeight);\n        const descriptionCenterX = left + width / 2;\n        context.textBaseline = 'top';\n        // skill name\n        context.font = 'bold ' + fontSize + 'px sans-serif';\n        context.textAlign = 'left';\n        context.textBaseline = 'middle';\n        context.fillStyle = '#080';\n        context.fillText(selectedSkill.name, left + 5, top + Math.floor(titleHeight / 2));\n        top += titleHeight + 5;\n        context.textBaseline = 'top';\n        if (leftDescription.length) {\n            context.font = fontSize + 'px sans-serif';\n            context.textAlign = 'center';\n            context.fillStyle = 'white';\n            context.fillText(leftDescription, descriptionCenterX, top);\n            top += 5 + fontSize;\n        }\n        context.font = 'bold ' + Math.ceil(fontSize * 1.2) + 'px sans-serif';\n        if (skillLevel === 0) {\n            context.fillStyle = '#0C0';\n            context.textAlign = 'center';\n            context.fillText(formattedNewValue, descriptionCenterX, top);\n        }\n        else {\n            context.fillStyle = 'white';\n            context.textAlign = 'right';\n            context.fillText(formattedValue, descriptionCenterX - 30, top);\n            context.fillStyle = '#0C0';\n            context.textAlign = 'center';\n            context.fillText('->', descriptionCenterX, top);\n            context.fillText('-', descriptionCenterX, top);\n            context.fillText('--', descriptionCenterX, top);\n            context.textAlign = 'left';\n            context.fillText(formattedNewValue, descriptionCenterX + 30, top);\n        }\n        top += 5 + Math.ceil(fontSize * 1.2);\n        context.textAlign = 'center';\n        context.font = fontSize + 'px sans-serif';\n        context.fillStyle = 'white';\n        context.fillText(rightDescription, descriptionCenterX, top);\n    }\n}\nconst skillButton = {\n    onClick(state) {\n        if (state.currentScene === 'skills') {\n            // return to the previous scene.\n            (0,app_handleBackAction__WEBPACK_IMPORTED_MODULE_2__.triggerBackAction)();\n            delete state.avatar.selectedSkill;\n        }\n        else {\n            // store the previous scene to return to it when we close the skill scene.\n            (0,app_state__WEBPACK_IMPORTED_MODULE_5__.pushScene)(state, 'skills');\n        }\n    },\n    isVisible(state) {\n        return (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getTotalSkillPoints)(state) > 0 && !state.globalPosition.isFastMode && !state.globalPosition.isFixingGPS;\n    },\n    render(context, state) {\n        const { iconSize } = state.display;\n        context.textBaseline = 'middle';\n        context.textAlign = 'center';\n        context.font = 'bold ' + Math.floor(iconSize * 1.25) + 'px sans-serif';\n        const points = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getAvailableSkillPoints)(state);\n        context.fillStyle = 'white';\n        const target = this.target;\n        const padding = Math.floor(target.w / 10);\n        const size = Math.floor(target.w / 4);\n        context.fillRect(target.x + padding, target.y + Math.floor((target.h - size) / 2), target.w - 2 * padding, size);\n        context.fillRect(target.x + Math.floor((target.w - size) / 2), target.y + padding, size, target.h - 2 * padding);\n        context.fillStyle = points ? 'red' : '#888';\n        context.fillRect(target.x + padding + 2, target.y + Math.floor((target.h - size) / 2) + 2, target.w - padding * 2 - 4, size - 4);\n        context.fillRect(target.x + Math.floor((target.w - size) / 2) + 2, target.y + padding + 2, size - 4, target.h - 2 * padding - 4);\n        if (points) {\n            context.textBaseline = 'bottom';\n            context.textAlign = 'right';\n            context.font = 'bold ' + Math.floor(iconSize / 4) + 'px sans-serif';\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedText)(context, `${points}`, 'red', 'white', 1, target.x + target.w - 2, target.y + target.h);\n        }\n    },\n    updateTarget(state) {\n        const { canvas, iconSize } = state.display;\n        // Skill Button is in the bottom right corner.\n        this.target = {\n            w: iconSize,\n            h: iconSize,\n            x: canvas.width - 10 - iconSize,\n            y: canvas.height - 10 - iconSize,\n        };\n    },\n    target: { x: 0, y: 0, w: 0, h: 0 },\n};\nfunction getSkillButton() {\n    return skillButton;\n}\nconst upgradeSkillButton = {\n    onClick(state) {\n        const { selectedSkill } = state.avatar;\n        if (!selectedSkill) {\n            return;\n        }\n        state.avatar.usedSkillPoints += (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillCost)(state, selectedSkill);\n        state.avatar.affinityBonuses[selectedSkill.affinity] += (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillCost)(state, selectedSkill);\n        state.saved.avatar.skillLevels[selectedSkill.key] = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillLevel)(state, selectedSkill.key) + 1;\n        delete state.avatar.selectedSkill;\n        (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.updatePlayerStats)(state);\n    },\n    isDisabled(state) {\n        return !state.avatar.selectedSkill\n            || !(0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.canLearnSkill)(state, state.avatar.selectedSkill)\n            || !(0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.canAffordSkill)(state, state.avatar.selectedSkill);\n    },\n    isVisible(state) {\n        return !!state.avatar.selectedSkill;\n    },\n    render(context, state) {\n        const { iconSize } = state.display;\n        const { selectedSkill } = state.avatar;\n        if (!selectedSkill) {\n            return;\n        }\n        const isAvailable = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.canLearnSkill)(state, selectedSkill);\n        const cost = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillCost)(state, selectedSkill);\n        const remainingPoints = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getAvailableSkillPoints)(state) - cost;\n        const reqiurementsSatisfied = isAvailable && (remainingPoints >= 0);\n        const arrowColor = reqiurementsSatisfied ? 'green' : 'red';\n        const textColor = reqiurementsSatisfied ? 'white' : 'red';\n        context.save();\n        if (!reqiurementsSatisfied)\n            context.globalAlpha = .5;\n        context.textBaseline = 'middle';\n        context.textAlign = 'left';\n        context.font = Math.floor(3 * iconSize / 4) + 'px sans-serif';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawSolidTintedImage)(context, arrowColor, app_images__WEBPACK_IMPORTED_MODULE_4__.upArrows, this.target);\n        const text = isAvailable ? `${cost}` : '---';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, text, textColor, 'black', this.target.x + iconSize, this.target.y + this.target.h / 2);\n        context.restore();\n    },\n    updateTarget(state) {\n        const { canvas, iconSize } = state.display;\n        // Upgrade Button is in the bottom center.\n        this.target = {\n            w: iconSize,\n            h: iconSize,\n            x: Math.floor((canvas.width - iconSize) / 2),\n            y: canvas.height - 10 - iconSize,\n        };\n    },\n    target: { x: 0, y: 0, w: 0, h: 0 }\n};\nconst skillButtons = app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.skills.map(skill => ({\n    skill,\n    target: { x: 0, y: 0, w: 0, h: 0 },\n    onClick(state) {\n        if (state.avatar.selectedSkill !== skill) {\n            state.avatar.selectedSkill = skill;\n        }\n        else {\n            delete state.avatar.selectedSkill;\n        }\n    },\n    render(context, state) {\n        const { border, skillSize } = getSkillDisplayValues(state);\n        const skillIsAvailable = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.canLearnSkill)(state, skill);\n        const skillIsAffordable = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.canAffordSkill)(state, skill);\n        const skillLevel = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_7__.getSkillLevel)(state, skill.key);\n        const { selectedSkill } = state.avatar;\n        const target = this.target;\n        context.save();\n        context.fillStyle = (!skillLevel && selectedSkill !== skill) ? '#777' : '#aaa';\n        if (!skillLevel && selectedSkill !== skill && !skillIsAvailable)\n            context.globalAlpha = .2;\n        else\n            context.globalAlpha = .5;\n        context.fillRect(target.x, target.y, target.w, target.h - 2);\n        context.restore();\n        context.save();\n        if (!skillLevel && selectedSkill !== skill) {\n            context.globalAlpha = .3;\n        }\n        // Icon is drawn transparent if the ability hasn't been learned yet.\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, skill.source, target);\n        if (skill.secondSource) {\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, skill.secondSource, { x: target.x + target.w / 2, y: target.y + target.h / 2,\n                w: target.w / 2, h: target.h / 2 });\n        }\n        context.restore();\n        // Use evenodd to draw the border over the background+icon\n        context.fillStyle = (selectedSkill === skill)\n            ? ((skillIsAvailable && skillIsAffordable) ? '#080' : 'red')\n            : (skillIsAvailable ? 'white' : '#333');\n        context.beginPath();\n        context.rect(target.x, target.y, target.w, target.h);\n        context.rect(target.x + border, target.y + border, target.w - 2 * border, target.h - 2 * border);\n        context.fill('evenodd');\n        if (skillLevel || selectedSkill === skill) {\n            let level = skillLevel, color = 'white';\n            if (selectedSkill === skill) {\n                level++;\n                color = (skillIsAffordable && skillIsAvailable) ? 'green' : 'red';\n            }\n            context.textBaseline = 'bottom';\n            context.textAlign = 'left';\n            context.font = 'bold ' + Math.floor(skillSize / 3) + 'px sans-serif';\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedText)(context, `${level}`, color, 'black', 1, target.x + 2 * border, target.y + target.h - 2);\n        }\n    },\n    updateTarget(state) {\n        const { centerX, centerY, skillSpacing, skillSize } = getSkillDisplayValues(state);\n        this.target = {\n            x: centerX + skill.x * skillSpacing - skillSize / 2, w: skillSize,\n            y: centerY + skill.y * skillSpacing - skillSize / 2, h: skillSize,\n        };\n    },\n}));\nfunction getSkillHudButtons(state) {\n    return [\n        skillButton,\n        upgradeSkillButton,\n        ...skillButtons,\n    ];\n}\nlet lastCanvasSize;\n// Update the targets for skill buttons for the current display settings.\n// This should be called each frame before checking for user clicks or rendering the buttons.\nfunction updateAllSkillButtonTargets(state) {\n    const { canvas } = state.display;\n    if ((lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.w) === canvas.width && (lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.h) === canvas.height) {\n        return;\n    }\n    lastCanvasSize = { w: canvas.width, h: canvas.height };\n    for (const skillButton of getSkillHudButtons(state)) {\n        skillButton.updateTarget(state);\n    }\n}\nfunction handleSkillsClick(state, x, y) {\n    updateAllSkillButtonTargets(state);\n    return (0,app_hud__WEBPACK_IMPORTED_MODULE_3__.handleHudButtonClick)(state, x, y, getSkillHudButtons(state));\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/scenes/skillsScene.ts?");

/***/ }),

/***/ "./app/scenes/titleScene.ts":
/*!**********************************!*\
  !*** ./app/scenes/titleScene.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawTitleScene\": () => (/* binding */ drawTitleScene),\n/* harmony export */   \"handleTitleClick\": () => (/* binding */ handleTitleClick)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_hud__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/hud */ \"./app/hud.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_utils_loadSaveSlot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/loadSaveSlot */ \"./app/utils/loadSaveSlot.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n\n\n\n\n\n\n\n\nconst titleBackground = (0,app_images__WEBPACK_IMPORTED_MODULE_4__.requireImage)('gfx/beach.jpg');\nconst saveColors = ['red', 'green', 'blue'];\nconst saveLabels = ['A', 'B', 'C'];\nfunction getTitleDisplayValues(state) {\n    const { canvas, iconSize } = state.display;\n    const titleFontSize = Math.min(200, Math.floor(canvas.height / 4), Math.floor(canvas.width / 5));\n    const narrow = canvas.height > canvas.width;\n    let loadButtonWidth = Math.ceil(narrow ? Math.min(300, canvas.width / 2) : canvas.width / 5);\n    const buttonHeight = Math.ceil(loadButtonWidth / 2);\n    const deleteButtonWidth = Math.floor(buttonHeight / 3);\n    loadButtonWidth = Math.round(loadButtonWidth * 4 / 3);\n    const totalButtonWidth = loadButtonWidth + deleteButtonWidth;\n    const padding = 10;\n    let x, y;\n    if (narrow) {\n        y = 2 * titleFontSize + Math.max(0, ((canvas.height - 2 * titleFontSize) - buttonHeight * 3 - padding * 2) / 2);\n        x = Math.floor((canvas.width - totalButtonWidth) / 2);\n    }\n    else {\n        y = 2 * titleFontSize + Math.max(0, ((canvas.height - 2 * titleFontSize) - buttonHeight) / 2);\n        x = Math.floor((canvas.width - totalButtonWidth * 3 - 2 * padding) / 2);\n    }\n    const border = 4;\n    return {\n        canvas,\n        narrow,\n        // Width of the\n        loadButtonWidth,\n        deleteButtonWidth,\n        totalButtonWidth,\n        buttonHeight,\n        w: canvas.width,\n        h: canvas.height,\n        x, y,\n        border,\n        titleFontSize,\n        iconSize,\n        padding,\n    };\n}\nclass LoadSaveSlotButton {\n    constructor(index) {\n        this.target = { x: 0, y: 0, w: 0, h: 0 };\n        this.deleteTarget = { x: 0, y: 0, w: 0, h: 0 };\n        this.index = index;\n    }\n    onClick(state, x, y) {\n        (0,app_utils_loadSaveSlot__WEBPACK_IMPORTED_MODULE_5__.loadSaveSlot)(state, this.index);\n    }\n    render(context, state) {\n        const { border, buttonHeight } = getTitleDisplayValues(state);\n        const statsPadding = 4;\n        const localIconSize = Math.round((buttonHeight - 4 * statsPadding - 2 * border) / 3);\n        const smallFontSize = Math.floor(localIconSize * .9);\n        const smallFont = smallFontSize + 'px sans-serif';\n        const saveSlot = state.saveSlots[this.index];\n        const slotLabelWidth = Math.round(buttonHeight / 4);\n        context.fillStyle = 'black';\n        context.fillRect(this.target.x, this.target.y, this.target.w, this.target.h);\n        context.fillStyle = 'white';\n        context.fillRect(this.target.x + border, this.target.y + border, this.target.w - 2 * border, this.target.h - 2 * border);\n        context.fillStyle = saveColors[this.index];\n        context.fillRect(this.target.x + border, this.target.y + border, slotLabelWidth, this.target.h - 2 * border);\n        context.font = Math.floor(buttonHeight / 4) + 'px sans-serif';\n        context.fillStyle = 'white';\n        context.textAlign = 'center';\n        context.textBaseline = 'middle';\n        context.fillText(saveLabels[this.index], this.target.x + border + Math.round(slotLabelWidth / 2), this.target.y + Math.round(buttonHeight / 2));\n        let statsTop = this.target.y + border + statsPadding;\n        const statsLeft = this.target.x + border + statsPadding + slotLabelWidth;\n        const statsWidth = this.target.w - slotLabelWidth;\n        context.font = smallFont;\n        context.textAlign = 'left';\n        context.textBaseline = 'middle';\n        context.fillStyle = 'black';\n        const level = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_7__.abbreviateNumber)(saveSlot.avatar.level);\n        const levelBonus = (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.getLevelBonus)(state, saveSlot.avatar.level);\n        // Level\n        const levelText = 'Lv ' + level;\n        context.fillText(levelText, statsLeft + statsPadding, statsTop + Math.round(localIconSize / 2));\n        // Health\n        const middleLeft = statsLeft + Math.ceil(statsWidth / 2);\n        const lifeText = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_7__.abbreviateNumber)(Math.round(saveSlot.avatar.healthBonus * levelBonus));\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.heartSource, { x: middleLeft, y: statsTop, w: localIconSize, h: localIconSize });\n        context.fillStyle = 'red';\n        context.fillText(lifeText, middleLeft + localIconSize, statsTop + Math.round(localIconSize / 2));\n        statsTop += localIconSize + statsPadding;\n        context.fillStyle = 'black';\n        const attackText = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_7__.abbreviateNumber)(Math.round(saveSlot.avatar.attackBonus * levelBonus));\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.swordSource, { x: statsLeft, y: statsTop, w: localIconSize, h: localIconSize });\n        context.fillText(attackText, statsLeft + localIconSize, statsTop + Math.round(localIconSize / 2));\n        const defenseText = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_7__.abbreviateNumber)(Math.round(saveSlot.avatar.defenseBonus * levelBonus));\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.shieldSource, { x: middleLeft, y: statsTop, w: localIconSize, h: localIconSize });\n        context.fillText(defenseText, middleLeft + localIconSize, statsTop + Math.round(localIconSize / 2));\n        statsTop += localIconSize + statsPadding;\n        const coinsText = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_7__.abbreviateNumber)(Math.round(saveSlot.coins));\n        context.fillStyle = 'gold';\n        const coinsLeft = statsLeft + Math.ceil(statsWidth / 4);\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.outlinedMoneySource, { x: coinsLeft, y: statsTop, w: localIconSize, h: localIconSize });\n        context.fillText(coinsText, coinsLeft + localIconSize, statsTop + Math.round(localIconSize / 2));\n    }\n    updateTarget(state) {\n        const { buttonHeight, loadButtonWidth, narrow, padding, totalButtonWidth, x, y } = getTitleDisplayValues(state);\n        if (narrow) {\n            this.target = {\n                x,\n                y: y + this.index * (buttonHeight + padding),\n                w: loadButtonWidth,\n                h: buttonHeight\n            };\n        }\n        else {\n            this.target = {\n                x: x + this.index * (totalButtonWidth + padding),\n                y,\n                w: loadButtonWidth,\n                h: buttonHeight\n            };\n        }\n    }\n}\nclass DeleteSaveSlotButton {\n    constructor(index) {\n        this.target = { x: 0, y: 0, w: 0, h: 0 };\n        this.index = index;\n    }\n    onClick(state) {\n        (0,app_saveGame__WEBPACK_IMPORTED_MODULE_6__.deleteSaveSlot)(state, this.index);\n    }\n    render(context, state) {\n        const { border, buttonHeight } = getTitleDisplayValues(state);\n        context.fillStyle = 'black';\n        context.fillRect(this.target.x, this.target.y, this.target.w, this.target.h);\n        context.fillStyle = '#AAA';\n        context.fillRect(this.target.x, this.target.y + border, this.target.w - border, this.target.h - 2 * border);\n        const trashSize = this.target.w;\n        const trashTarget = { x: this.target.x - Math.round(border / 2), y: this.target.y + (buttonHeight - trashSize) / 2, w: trashSize, h: trashSize };\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.trashSource, trashTarget);\n    }\n    updateTarget(state) {\n        const { buttonHeight, deleteButtonWidth, loadButtonWidth, narrow, padding, totalButtonWidth, x, y } = getTitleDisplayValues(state);\n        if (narrow) {\n            this.target = {\n                x: x + loadButtonWidth,\n                y: y + this.index * (buttonHeight + padding),\n                w: deleteButtonWidth,\n                h: buttonHeight\n            };\n        }\n        else {\n            this.target = {\n                x: x + loadButtonWidth + this.index * (totalButtonWidth + padding),\n                y,\n                w: deleteButtonWidth,\n                h: buttonHeight\n            };\n        }\n    }\n}\nconst titleButtons = [\n    new LoadSaveSlotButton(0), new LoadSaveSlotButton(1), new LoadSaveSlotButton(2),\n    new DeleteSaveSlotButton(0), new DeleteSaveSlotButton(1), new DeleteSaveSlotButton(2),\n];\nfunction getTitleButtons() {\n    return titleButtons;\n}\nlet lastCanvasSize;\nfunction updateAllTitleButtonTargets(state) {\n    const { canvas } = state.display;\n    if ((lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.w) === canvas.width && (lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.h) === canvas.height) {\n        return;\n    }\n    lastCanvasSize = { w: canvas.width, h: canvas.height };\n    for (const button of getTitleButtons()) {\n        button.updateTarget(state);\n    }\n}\nfunction handleTitleClick(state, x, y) {\n    updateAllTitleButtonTargets(state);\n    (0,app_hud__WEBPACK_IMPORTED_MODULE_3__.handleHudButtonClick)(state, x, y, getTitleButtons());\n}\nfunction drawTitleBackground(context, state) {\n    const { canvas } = state.display;\n    const backgroundScale = Math.max(canvas.width / titleBackground.width, canvas.height / titleBackground.height);\n    const w = Math.ceil(titleBackground.width * backgroundScale);\n    const h = Math.ceil(titleBackground.height * backgroundScale);\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, { image: titleBackground, x: 0, y: 0, w: titleBackground.width, h: titleBackground.height }, { x: (canvas.width - w) / 2, y: (canvas.height - h) / 2, w, h });\n}\nfunction drawTitleScene(context, state) {\n    const { canvas, iconSize, titleFontSize } = getTitleDisplayValues(state);\n    drawTitleBackground(context, state);\n    context.fillStyle = 'gold';\n    context.font = 'bold ' + titleFontSize + 'px sans-serif';\n    context.textAlign = 'center';\n    context.textBaseline = 'top';\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedText)(context, 'Geo', 'brown', 'white', 3, canvas.width / 2, 10);\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawOutlinedText)(context, 'Crasher', 'gold', 'white', 3, canvas.width / 2, titleFontSize);\n    updateAllTitleButtonTargets(state);\n    (0,app_hud__WEBPACK_IMPORTED_MODULE_3__.renderHudButtons)(context, state, getTitleButtons());\n    context.font = Math.round(iconSize / 2) + 'px sans-serif';\n    context.textAlign = 'right';\n    context.textBaseline = 'bottom';\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawEmbossedText)(context, app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.version, 'white', 'black', canvas.width - 5, canvas.height - 5);\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/scenes/titleScene.ts?");

/***/ }),

/***/ "./app/scenes/treasureMapScene.ts":
/*!****************************************!*\
  !*** ./app/scenes/treasureMapScene.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawTreasureMapScene\": () => (/* binding */ drawTreasureMapScene),\n/* harmony export */   \"getTreasureMapButton\": () => (/* binding */ getTreasureMapButton),\n/* harmony export */   \"handleTreasureMapClick\": () => (/* binding */ handleTreasureMapClick),\n/* harmony export */   \"updateTreasureMap\": () => (/* binding */ updateTreasureMap)\n/* harmony export */ });\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_handleBackAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/handleBackAction */ \"./app/handleBackAction.ts\");\n/* harmony import */ var app_hud__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/hud */ \"./app/hud.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/scenes/dungeonScene */ \"./app/scenes/dungeonScene.ts\");\n/* harmony import */ var app_utils_hud__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/hud */ \"./app/utils/hud.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n/* harmony import */ var app_utils_treasureMap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/utils/treasureMap */ \"./app/utils/treasureMap.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction startNewTreasureMap(state) {\n    const size = 3 + Math.ceil(Math.sqrt(state.saved.avatar.level));\n    state.saved.treasureHunt.currentMap = {\n        seed: Math.random(),\n        size,\n        revealedCoordinates: [],\n    };\n    (0,app_utils_treasureMap__WEBPACK_IMPORTED_MODULE_12__.initializeTreasureMapStateFromSave)(state);\n}\nfunction showTreasureMapScene(state) {\n    delete state.selectedTile;\n    delete state.battle.engagedMonster;\n    if (!state.saved.treasureHunt.currentMap) {\n        startNewTreasureMap(state);\n    }\n    (0,app_state__WEBPACK_IMPORTED_MODULE_9__.pushScene)(state, 'treasureMap');\n}\nfunction updateTreasureMap(state) {\n    const savedMap = state.saved.treasureHunt.currentMap;\n    // Advance the reveal animation time once the dungeon is discovered.\n    if (state.treasureHunt.currentMap && (savedMap === null || savedMap === void 0 ? void 0 : savedMap.dungeonLevel)) {\n        state.treasureHunt.currentMap.revealAnimationTime += app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.frameLength;\n    }\n}\nfunction revealTreasureMapTile(state, x, y) {\n    const savedMap = state.saved.treasureHunt.currentMap;\n    const currentMap = state.treasureHunt.currentMap;\n    if (!state.saved.treasureHunt.mapCount || !savedMap || !currentMap) {\n        return;\n    }\n    if (x < 0 || y < 0 || x >= savedMap.size || y >= savedMap.size) {\n        return;\n    }\n    if (currentMap.tiles[y][x].isRevealed) {\n        return;\n    }\n    savedMap.revealedCoordinates.push([x, y]);\n    currentMap.tiles[y][x].isRevealed = true;\n    state.saved.treasureHunt.mapCount--;\n    const [tx, ty] = (0,app_utils_treasureMap__WEBPACK_IMPORTED_MODULE_12__.getTreasureLocation)(savedMap);\n    if (tx === x && ty === y) {\n        savedMap.dungeonLevel = (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_10__.getDungeonLevel)(state, state.saved.avatar.level);\n        currentMap.dungeon = (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_10__.createDungeon)(state, savedMap.dungeonLevel);\n    }\n    (0,app_saveGame__WEBPACK_IMPORTED_MODULE_6__.saveGame)(state);\n}\nfunction handleTreasureMapClick(state, x, y) {\n    var _a;\n    updateAllTreasureMapButtonTargets(state);\n    if ((0,app_hud__WEBPACK_IMPORTED_MODULE_3__.handleHudButtonClick)(state, x, y, getTreasureMapButtons())) {\n        return;\n    }\n    // The treasure map is not interactive after the dungeon has been discovered.\n    if ((_a = state.treasureHunt.currentMap) === null || _a === void 0 ? void 0 : _a.dungeon) {\n        return;\n    }\n    const clickedCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_11__.unproject)(state, [x, y]);\n    const clickedGridCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_11__.toGridCoords)(state, clickedCoords);\n    revealTreasureMapTile(state, clickedGridCoords[0], clickedGridCoords[1]);\n}\nfunction getTreasureMapButtons() {\n    return [\n        (0,app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_7__.getEnterExitButton)(),\n        getTreasureMapButton(),\n    ];\n}\n// Update the targets for skill buttons for the current display settings.\n// This should be called each frame before checking for user clicks or rendering the buttons.\nlet lastCanvasSize;\nfunction updateAllTreasureMapButtonTargets(state) {\n    const { canvas } = state.display;\n    if ((lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.w) === canvas.width && (lastCanvasSize === null || lastCanvasSize === void 0 ? void 0 : lastCanvasSize.h) === canvas.height) {\n        return;\n    }\n    lastCanvasSize = { w: canvas.width, h: canvas.height };\n    for (const button of getTreasureMapButtons()) {\n        button.updateTarget(state);\n    }\n}\nfunction drawTreasureMapScene(context, state) {\n    const savedMap = state.saved.treasureHunt.currentMap;\n    const currentMap = state.treasureHunt.currentMap;\n    if (!savedMap || !currentMap) {\n        return;\n    }\n    const { canvas } = state.display;\n    const scaleToUse = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_11__.getActualScale)(state);\n    context.fillStyle = context.createPattern(app_images__WEBPACK_IMPORTED_MODULE_4__.darkStoneImage, 'repeat');\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    context.font = 'bold ' + Math.floor(app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.gridLength * scaleToUse) + 'px sans-serif';\n    const mapPattern = context.createPattern(app_images__WEBPACK_IMPORTED_MODULE_4__.oldMapImage, 'repeat');\n    const [tx, ty] = (0,app_utils_treasureMap__WEBPACK_IMPORTED_MODULE_12__.getTreasureLocation)(savedMap);\n    for (let y = 0; y < currentMap.tiles.length; y++) {\n        for (let x = 0; x < currentMap.tiles[y].length; x++) {\n            const tile = currentMap.tiles[y][x];\n            const target = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_11__.getGridRectangle)(state, [x, y]);\n            const distance = Math.abs(y - ty) + Math.abs(x - tx);\n            const isRevealed = tile.isRevealed || distance < currentMap.revealAnimationTime / 100;\n            if (!isRevealed) {\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.fillRectangle)(context, mapPattern, target);\n                context.beginPath();\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawRectangle)(context, target);\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawRectangle)(context, (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.pad)(target, -2));\n                context.fillStyle = '#444';\n                context.fill('evenodd');\n                context.fillStyle = '#666';\n                context.fillText('?', target.x + target.w / 2, target.y + target.h / 2);\n                continue;\n            }\n            let frame = app_images__WEBPACK_IMPORTED_MODULE_4__.grassSource;\n            if (distance > 6) {\n                frame = app_images__WEBPACK_IMPORTED_MODULE_4__.oceanSource;\n            }\n            else if (distance > 3) {\n                frame = app_images__WEBPACK_IMPORTED_MODULE_4__.shallowSource;\n            }\n            else if (distance > 1) {\n                frame = app_images__WEBPACK_IMPORTED_MODULE_4__.sandSource;\n            }\n            (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawFrame)(context, frame, target);\n            if (x === tx && y === ty && currentMap.dungeon) {\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawOutlinedImage)(context, 'red', 1, currentMap.dungeon.frame, target);\n            }\n            // Experimental rendering logic for indicating which squares the user has not manually explored\n            // after the entire treasure map is revealed. Allows players to review their guesses\n            // and brag if they find the dungeon in only a few guesses.\n            if (!tile.isRevealed) {\n                context.save();\n                context.globalAlpha *= 0.3;\n                (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.fillRectangle)(context, 'black', target);\n                context.restore();\n            }\n        }\n    }\n    if (currentMap.dungeon) {\n        (0,app_scenes_dungeonScene__WEBPACK_IMPORTED_MODULE_7__.drawDungeonStats)(context, state, currentMap.dungeon);\n    }\n    (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_8__.drawCoinsIndicator)(context, state);\n    (0,app_loot__WEBPACK_IMPORTED_MODULE_5__.drawLootTotals)(context, state, 1000);\n    (0,app_utils_hud__WEBPACK_IMPORTED_MODULE_8__.drawLifeIndicator)(context, state);\n    updateAllTreasureMapButtonTargets(state);\n    (0,app_hud__WEBPACK_IMPORTED_MODULE_3__.renderHudButtons)(context, state, getTreasureMapButtons());\n}\nconst treasureMapButton = {\n    onClick(state) {\n        if (state.currentScene === 'treasureMap') {\n            (0,app_handleBackAction__WEBPACK_IMPORTED_MODULE_2__.hideTreasureMap)(state);\n        }\n        else {\n            showTreasureMapScene(state);\n        }\n    },\n    isDisabled(state) {\n        return !!state.battle.engagedMonster && state.loot.collectingLoot.length > 0;\n    },\n    isVisible(state) {\n        if (state.currentScene === 'treasureMap') {\n            return true;\n        }\n        if (state.currentScene === 'map') {\n            // The journey/voyage mode button is displayed in this spot when a tile is selected.\n            if (state.selectedTile) {\n                return false;\n            }\n            return state.saved.treasureHunt.hadMap || state.saved.treasureHunt.mapCount > 0;\n        }\n        // This button is not rendered in other scenes.\n        return false;\n    },\n    render(context, state) {\n        const { iconSize } = state.display;\n        context.textBaseline = 'middle';\n        context.textAlign = 'right';\n        context.font = Math.floor(iconSize / 3) + 'px sans-serif';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_4__.treasureMapSource, this.target);\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawEmbossedText)(context, 'x' + state.saved.treasureHunt.mapCount, 'white', 'black', this.target.x + Math.floor(iconSize * .8), this.target.y + 3 * this.target.h / 4);\n    },\n    updateTarget(state) {\n        const { canvas, iconSize } = state.display;\n        this.target = {\n            x: 10,\n            y: canvas.height - 10 - iconSize,\n            w: iconSize,\n            h: iconSize,\n        };\n    },\n    target: { x: 0, y: 0, w: 0, h: 0 },\n};\nfunction getTreasureMapButton() {\n    return treasureMapButton;\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/scenes/treasureMapScene.ts?");

/***/ }),

/***/ "./app/state.ts":
/*!**********************!*\
  !*** ./app/state.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getDefaultState\": () => (/* binding */ getDefaultState),\n/* harmony export */   \"getState\": () => (/* binding */ getState),\n/* harmony export */   \"initializeState\": () => (/* binding */ initializeState),\n/* harmony export */   \"popScene\": () => (/* binding */ popScene),\n/* harmony export */   \"pushScene\": () => (/* binding */ pushScene)\n/* harmony export */ });\n/* harmony import */ var app_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/dom */ \"./app/dom.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n\n\n\nfunction getDefaultState() {\n    return {\n        currentScene: 'loading',\n        ignoreNextScenePop: false,\n        sceneStack: [],\n        // Start a few seconds into the future so that\n        // other time stamps can be initialized to 0 without\n        // having any effect.\n        time: 10000,\n        goalCoordinates: [],\n        saveSlotIndex: -1,\n        saveSlots: [],\n        saved: (0,app_saveGame__WEBPACK_IMPORTED_MODULE_2__.getDefaultSavedState)(),\n        display: {\n            canvas: app_dom__WEBPACK_IMPORTED_MODULE_0__.mainCanvas,\n            dungeonScale: 5, // ??? What value.\n            context: app_dom__WEBPACK_IMPORTED_MODULE_0__.mainContext,\n            iconSize: 16,\n        },\n        avatar: {\n            animationTime: 0,\n            maxHealth: 0,\n            attack: 0,\n            defense: 0,\n            affinityBonuses: {\n                health: 0,\n                attack: 0,\n                defense: 0,\n                money: 0,\n            },\n            usedSkillPoints: 0,\n        },\n        battle: {\n            damageIndicators: [],\n        },\n        dungeon: {},\n        gems: {\n            colorCounters: {},\n            gemMarkers: [],\n        },\n        globalPosition: {\n            restartWatchTime: 0,\n            direction: 'up',\n            isFixingGPS: false,\n            endFastModeTime: 0,\n            endFixingGPSTime: 0,\n            isFastMode: false,\n            isStartingFastMode: false,\n        },\n        loot: {\n            activePowerupMarkers: new Set(),\n            collectingLoot: [],\n            collectionBonus: 0,\n            coinsCollected: 0,\n            lootCollectedTime: 0,\n            lootInRadius: [],\n            lootInMonsterRadius: [],\n            hideStatsAt: 0,\n            initialLevel: 0,\n            initialSkillPoints: 0,\n            initialMaxHealth: 0,\n            initialAttack: 0,\n            initialDefense: 0,\n        },\n        treasureHunt: {},\n        world: {\n            activeTiles: [],\n            displayScale: app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.maxScale,\n            allTiles: {},\n            savedTiles: {},\n            activeMonsterMarkers: [],\n            levelSums: [],\n            selectableTiles: new Set(),\n            journeyModeOrigin: [],\n            journeyModePower: 0,\n            journeyModeTileLevel: 0,\n            journeyModeRewardBonus: 0,\n            journeyModeNextBossLevel: 0,\n        }\n    };\n}\nlet state;\nfunction getState() {\n    return state;\n}\nfunction initializeState() {\n    state = getDefaultState();\n    window.state = state;\n    (0,app_saveGame__WEBPACK_IMPORTED_MODULE_2__.initializeSaveSlots)(state);\n}\nfunction pushScene(state, newScene) {\n    window.history.pushState({ 'scene': newScene }, '');\n    state.sceneStack.push(state.currentScene);\n    state.currentScene = newScene;\n}\nfunction popScene(state) {\n    const newScene = state.sceneStack.pop();\n    if (newScene) {\n        state.currentScene = newScene;\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/state.ts?");

/***/ }),

/***/ "./app/statsBox.ts":
/*!*************************!*\
  !*** ./app/statsBox.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawAvatarStats\": () => (/* binding */ drawAvatarStats),\n/* harmony export */   \"drawMonsterStats\": () => (/* binding */ drawMonsterStats),\n/* harmony export */   \"drawStatsBox\": () => (/* binding */ drawStatsBox)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n\n\n\n\nfunction getStatsBoxSize(state) {\n    const { iconSize } = state.display;\n    const localIconSize = Math.floor(iconSize / 2);\n    return { w: localIconSize * 8, h: localIconSize * 4 };\n}\nfunction drawStatsBox(context, state, x, y, level, name, currentHealth, maxHealth, attack, defense, experience = 0, nextLevel = 0) {\n    const { iconSize } = state.display;\n    const localIconSize = Math.floor(iconSize / 2);\n    const fontSize = Math.floor(3 * localIconSize / 4);\n    const { w, h } = getStatsBoxSize(state);\n    const padding = Math.floor(localIconSize / 4);\n    context.fillStyle = '#BBB';\n    context.fillRect(x, y, w, h);\n    context.fillStyle = '#FFF';\n    context.fillRect(x + 1, y + 1, w - 2, h - 2);\n    context.fillStyle = '#004';\n    context.fillRect(x + 3, y + 3, w - 6, h - 6);\n    context.textBaseline = 'top';\n    context.textAlign = 'left';\n    context.font = fontSize + 'px sans-serif';\n    context.fillStyle = 'white';\n    y += padding;\n    const text = 'Lv ' + level + ' ' + name;\n    context.fillText(text, x + padding, y);\n    if (nextLevel) {\n        const metrics = context.measureText(text);\n        const left = x + padding + metrics.width + 5;\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawBar)(context, { x: left, y, w: w - metrics.width - 2 * padding - 5, h: localIconSize - 5 }, '#ccc', 'orange', experience / nextLevel);\n    }\n    y += localIconSize;\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawBar)(context, { x: x + padding, y, w: w - 2 * padding, h: 6 }, 'white', 'red', currentHealth / maxHealth);\n    y += padding;\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_2__.heartSource, { x: x + padding, y: y, w: localIconSize, h: localIconSize });\n    context.fillText((0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.abbreviateNumber)(currentHealth) + ' / ' + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.abbreviateNumber)(maxHealth), x + localIconSize + 2 * padding, y);\n    y += localIconSize + padding;\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_2__.swordSource, { x: x + padding, y: y, w: localIconSize, h: localIconSize });\n    context.fillText((0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.abbreviateNumber)(attack), x + localIconSize + 2 * padding, y);\n    var centerX = Math.floor(x + w / 2);\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_1__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_2__.shieldSource, { x: centerX + padding, y: y, w: localIconSize, h: localIconSize });\n    context.fillText((0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.abbreviateNumber)(defense), centerX + localIconSize + padding, y);\n}\nfunction drawAvatarStats(context, state) {\n    drawStatsBox(context, state, 5, 5, state.saved.avatar.level, 'Hero', state.saved.avatar.currentHealth, state.avatar.maxHealth, state.avatar.attack, state.avatar.defense, state.saved.avatar.experience, (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.experienceForNextLevel)(state));\n}\nfunction drawMonsterStats(context, state) {\n    var _a;\n    if (!((_a = state.selectedTile) === null || _a === void 0 ? void 0 : _a.monsterMarker)) {\n        return;\n    }\n    const { canvas, iconSize } = state.display;\n    const monster = state.selectedTile.monsterMarker.monster;\n    const rectangle = state.selectedTile.target;\n    const { w, h } = getStatsBoxSize(state);\n    state.loot.hideStatsAt = state.time + 1500;\n    // The monster stats are drawn on the right side of the screen, ideally just below the monster:\n    const x = canvas.width - w - 5;\n    let y = rectangle.y + rectangle.h;\n    // Make sure the box isn't shown too high or too low on the screen.\n    y = Math.max(iconSize, Math.min(canvas.height - h - iconSize, y));\n    drawStatsBox(context, state, x, y, monster.level, monster.name, monster.currentHealth, monster.maxHealth, monster.attack, monster.defense);\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/statsBox.ts?");

/***/ }),

/***/ "./app/utils/Random.ts":
/*!*****************************!*\
  !*** ./app/utils/Random.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Random = {\n    /**\n     * @param {number} min  The smallest returned value\n     * @param {number} max  The largest returned value\n     */\n    integerRange(A, B) {\n        const min = Math.min(A, B);\n        const max = Math.max(A, B);\n        return Math.floor(Math.random() * (max + 1 - min)) + min;\n    },\n    /**\n     * @param {number} min  The smallest returned value\n     * @param {number} max  The largest returned value\n     */\n    range(A, B) {\n        const min = Math.min(A, B);\n        const max = Math.max(A, B);\n        return Math.random() * (max - min) + min;\n    },\n    /**\n     * @param {Collection} collection  The collection of elements to return random element from\n     */\n    element(collection) {\n        if (Array.isArray(collection)) {\n            const array = collection;\n            return array[Math.floor(Math.random() * array.length)];\n        }\n        if (collection.constructor == Object) {\n            const keys = Object.keys(collection);\n            return collection[this.element(keys)];\n        }\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\n    },\n    /**\n     * @param {Array} array  The array of elements to return random element from\n     */\n    removeElement(collection) {\n        if (Array.isArray(collection)) {\n            const array = collection;\n            return array.splice(Math.floor(Math.random() * (array.length - 1)), 1)[0];\n        }\n        if (collection.constructor == Object) {\n            const keys = Object.keys(collection);\n            const key = this.element(keys);\n            const value = collection[key];\n            delete collection[key];\n            return value;\n        }\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\n    },\n    /**\n     * Shuffles an array.\n     *\n     * Knuth algorithm found at:\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n     *\n     * @param {Array} array  The array of elements to shuffle\n     */\n    shuffle(array) {\n        array = [...array];\n        let currentIndex = array.length, temporaryValue, randomIndex;\n        // While there remain elements to shuffle...\n        while (0 !== currentIndex) {\n            // Pick a remaining element...\n            randomIndex = Math.floor(Math.random() * currentIndex);\n            currentIndex -= 1;\n            // And swap it with the current element.\n            temporaryValue = array[currentIndex];\n            array[currentIndex] = array[randomIndex];\n            array[randomIndex] = temporaryValue;\n        }\n        return array;\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Random);\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/Random.ts?");

/***/ }),

/***/ "./app/utils/SRandom.ts":
/*!******************************!*\
  !*** ./app/utils/SRandom.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst MAX_INT = 2 ** 32;\n// Decent pseudo random number generator based on:\n// https://en.wikipedia.org/wiki/Xorshift\n// Values seem fairly evenly distributed on [0, 1)\nfunction nextSeed(seed) {\n    let x = Math.floor(MAX_INT * seed);\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return (x / MAX_INT) + 0.5;\n}\nfunction numberToSeed(number) {\n    return nextSeed((Math.cos(number) + 1) / 2);\n}\n// Seeded random number generator.\nclass SRandom {\n    constructor(seed) {\n        this._seed = seed;\n    }\n    // Return an instance of SRandom with a seed based on the given value.\n    seed(value) {\n        return new SRandom(numberToSeed(value));\n    }\n    // Create a new seed based on the current seed and a given value.\n    addSeed(value) {\n        return this.seed(this._seed + value);\n    }\n    nextSeed() {\n        return new SRandom(nextSeed(this._seed));\n    }\n    random() {\n        return nextSeed(this._seed);\n    }\n    // This generates a random number and advances *this* geneator to the next seed.\n    generateAndMutate() {\n        this._seed = nextSeed(this._seed);\n        return this._seed;\n    }\n    /**\n     * @param {number} min  The smallest returned value\n     * @param {number} max  The largest returned value\n     */\n    range(A, B) {\n        var min = Math.min(A, B);\n        var max = Math.max(A, B);\n        return Math.floor(this.random() * (max + 1 - min)) + min;\n    }\n    /**\n     * @param {Collection} collection  The collection of elements to return random element from\n     */\n    element(collection) {\n        if (Array.isArray(collection)) {\n            return collection[Math.floor(this.random() * collection.length)];\n        }\n        if (collection.constructor == Object) {\n            const keys = Object.keys(collection);\n            return collection[this.element(keys)];\n        }\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\n    }\n    /**\n     * @param {Array} array  The array of elements to return random element from\n     */\n    removeElement(collection) {\n        if (Array.isArray(collection)) {\n            return collection[Math.floor(this.random() * collection.length)];\n        }\n        if (collection.constructor == Object) {\n            const keys = Object.keys(collection);\n            const key = this.element(keys);\n            const value = collection[key];\n            delete collection[key];\n            return value;\n        }\n        if (collection.constructor == Array) {\n            const array = collection;\n            return array.splice(Math.floor(this.random() * (array.length - 1)), 1)[0];\n        }\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\n    }\n    /**\n     * Shuffles an array.\n     *\n     * Knuth algorithm found at:\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\n     *\n     * @param {Array} array  The array of elements to shuffle\n     */\n    shuffle(array) {\n        let randomizer = this;\n        array = [...array];\n        let currentIndex = array.length, temporaryValue, randomIndex;\n        // While there remain elements to shuffle...\n        while (0 !== currentIndex) {\n            // Pick a remaining element...\n            randomIndex = Math.floor(randomizer.random() * currentIndex);\n            randomizer = randomizer.nextSeed();\n            currentIndex -= 1;\n            // And swap it with the current element.\n            temporaryValue = array[currentIndex];\n            array[currentIndex] = array[randomIndex];\n            array[randomIndex] = temporaryValue;\n        }\n        return array;\n    }\n}\n;\nconst instance = new SRandom(0.5);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/SRandom.ts?");

/***/ }),

/***/ "./app/utils/dungeon.ts":
/*!******************************!*\
  !*** ./app/utils/dungeon.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addDungeonToTile\": () => (/* binding */ addDungeonToTile),\n/* harmony export */   \"createDungeon\": () => (/* binding */ createDungeon),\n/* harmony export */   \"getAllNeighbors\": () => (/* binding */ getAllNeighbors),\n/* harmony export */   \"getDungeonFrame\": () => (/* binding */ getDungeonFrame),\n/* harmony export */   \"getDungeonLevel\": () => (/* binding */ getDungeonLevel)\n/* harmony export */ });\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n\nfunction getDungeonLevel(state, rawLevel) {\n    return Math.min(state.saved.world.dungeonLevelCap, rawLevel);\n}\nfunction getDungeonFrame(state, dungeonLevel) {\n    const isQuestDungeon = dungeonLevel >= state.saved.world.dungeonLevelCap;\n    return isQuestDungeon ? app_images__WEBPACK_IMPORTED_MODULE_0__.portalSource : app_images__WEBPACK_IMPORTED_MODULE_0__.shellSource;\n}\nfunction createDungeon(state, rawLevel) {\n    const level = getDungeonLevel(state, rawLevel);\n    const isQuestDungeon = level >= state.saved.world.dungeonLevelCap;\n    const dungeon = {\n        level,\n        isQuestDungeon,\n        name: isQuestDungeon ? 'Portal' : 'Hollow Shell',\n        numberOfFloors: Math.max(1, Math.floor(Math.sqrt(level) / 2)),\n        frame: getDungeonFrame(state, level),\n        currentFloor: {\n            tiles: [],\n        },\n        dungeonPosition: [0, 0],\n        allFloors: []\n    };\n    if (isQuestDungeon) {\n        dungeon.numberOfFloors++;\n    }\n    return dungeon;\n}\nfunction addDungeonToTile(state, tile, rawLevel) {\n    const dungeonMarker = {\n        dungeon: createDungeon(state, rawLevel),\n        tile,\n        x: tile.x,\n        y: tile.y\n    };\n    tile.dungeonMarker = dungeonMarker;\n}\nfunction getAllNeighbors(state, tile) {\n    var _a;\n    const neighbors = [];\n    if (!state.dungeon.currentDungeon) {\n        throw new Error('Current dungeon is not defined');\n    }\n    for (let y = -1; y <= 1; y++) {\n        for (let x = -1; x <= 1; x++) {\n            if (x === 0 && y === 0)\n                continue;\n            const neighbor = (_a = state.dungeon.currentDungeon.currentFloor.tiles[tile.y + y]) === null || _a === void 0 ? void 0 : _a[tile.x + x];\n            if (neighbor) {\n                neighbors.push(neighbor);\n            }\n        }\n    }\n    return neighbors;\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/dungeon.ts?");

/***/ }),

/***/ "./app/utils/hud.ts":
/*!**************************!*\
  !*** ./app/utils/hud.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawCoinsIndicator\": () => (/* binding */ drawCoinsIndicator),\n/* harmony export */   \"drawLifeIndicator\": () => (/* binding */ drawLifeIndicator),\n/* harmony export */   \"drawLootMarker\": () => (/* binding */ drawLootMarker)\n/* harmony export */ });\n/* harmony import */ var app_draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/draw */ \"./app/draw.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\nfunction drawCoinsIndicator(context, state) {\n    const { canvas, iconSize } = state.display;\n    const localIconSize = Math.floor(iconSize / 2);\n    const coinsText = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.abbreviateNumber)(state.saved.coins);\n    const fontSize = Math.floor(localIconSize * .9);\n    context.font = fontSize + 'px sans-serif';\n    context.textAlign = 'left';\n    context.textBaseline = 'middle';\n    const metrics = context.measureText(coinsText);\n    const margin = 10;\n    const x = canvas.width - metrics.width - localIconSize - 3 * margin;\n    const y = margin;\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_2__.outlinedMoneySource, { x, y, w: localIconSize, h: localIconSize });\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawEmbossedText)(context, coinsText, 'gold', 'white', x + localIconSize, y + Math.round(localIconSize / 2));\n}\nfunction drawLifeIndicator(context, state) {\n    const { iconSize } = state.display;\n    const localIconSize = Math.floor(iconSize / 2);\n    const fontSize = Math.floor(3 * localIconSize / 4);\n    context.font = fontSize + 'px sans-serif';\n    context.textAlign = 'left';\n    context.textBaseline = 'top';\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawFrame)(context, app_images__WEBPACK_IMPORTED_MODULE_2__.heartSource, { x: 10, y: 10, w: localIconSize, h: localIconSize });\n    const { currentHealth } = state.saved.avatar;\n    const { maxHealth } = state.avatar;\n    const healthText = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.abbreviateNumber)(currentHealth) + ' / ' + (0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.abbreviateNumber)(maxHealth);\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawEmbossedText)(context, healthText, 'red', 'white', 10 + localIconSize + 5, 10);\n    (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawBar)(context, { x: 10, y: 10 + localIconSize + 5, w: localIconSize * 4, h: 6 }, 'white', 'red', currentHealth / maxHealth);\n}\nfunction drawLootMarker(context, state, lootMarker, scaleToUse) {\n    var _a, _b;\n    const center = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_4__.project)(state, [lootMarker.x, lootMarker.y]);\n    const lootScale = app_gameConstants__WEBPACK_IMPORTED_MODULE_1__.gridLength * scaleToUse / 64;\n    const w = lootMarker.loot.frame.w * ((_a = lootMarker.loot.scale) !== null && _a !== void 0 ? _a : 1) * lootScale;\n    const h = lootMarker.loot.frame.h * ((_b = lootMarker.loot.scale) !== null && _b !== void 0 ? _b : 1) * lootScale;\n    const target = {\n        x: Math.round(center[0] - w / 2),\n        y: Math.round(center[1] - h / 2),\n        w, h,\n    };\n    if (lootMarker.isInMonsterRadius || lootMarker.isInAvatarRadius) {\n        const tintColor = lootMarker.isInMonsterRadius ? 'red' : 'gold';\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawTintedImage)(context, { color: tintColor, amount: .4 + Math.cos(state.time / 150) * .3 }, lootMarker.loot.frame, target);\n    }\n    else {\n        (0,app_draw__WEBPACK_IMPORTED_MODULE_0__.drawFrame)(context, lootMarker.loot.frame, target);\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/hud.ts?");

/***/ }),

/***/ "./app/utils/index.ts":
/*!****************************!*\
  !*** ./app/utils/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"abbreviateNumber\": () => (/* binding */ abbreviateNumber),\n/* harmony export */   \"getDistance\": () => (/* binding */ getDistance),\n/* harmony export */   \"isPointInRectangle\": () => (/* binding */ isPointInRectangle),\n/* harmony export */   \"percentText\": () => (/* binding */ percentText),\n/* harmony export */   \"rectanglesOverlap\": () => (/* binding */ rectanglesOverlap)\n/* harmony export */ });\nfunction getDistance(A, B) {\n    return Math.sqrt((A[0] - B[0]) * (A[0] - B[0]) + (A[1] - B[1]) * (A[1] - B[1]));\n}\nfunction isPointInRectangle(x, y, r) {\n    var _a, _b, _c, _d;\n    if (((_a = r === null || r === void 0 ? void 0 : r.x) !== null && _a !== void 0 ? _a : null) === null || ((_b = r === null || r === void 0 ? void 0 : r.y) !== null && _b !== void 0 ? _b : null) === null || ((_c = r === null || r === void 0 ? void 0 : r.w) !== null && _c !== void 0 ? _c : null) === null || ((_d = r === null || r === void 0 ? void 0 : r.h) !== null && _d !== void 0 ? _d : null) === null) {\n        return false;\n    }\n    return !(y <= r.y || y >= (r.y + r.h) || x <= r.x || x >= (r.x + r.w));\n}\nfunction rectanglesOverlap(A, B) {\n    return !(A.y + A.h <= B.y || A.y >= B.y + B.h || A.x + A.w <= B.x || A.x >= B.x + B.w);\n}\nfunction abbreviateNumber(number) {\n    if (number >= 1000000000000) {\n        return (number / 1000000000000 + '').slice(0, 5) + 'T';\n    }\n    if (number >= 1000000000) {\n        return (number / 1000000000 + '').slice(0, 5) + 'B';\n    }\n    if (number >= 1000000) {\n        return (number / 1000000 + '').slice(0, 5) + 'M';\n    }\n    if (number >= 10000) {\n        return (number / 1000 + '').slice(0, 5) + 'K';\n    }\n    return `${number}`;\n}\nfunction percentText(number, digits = 2) {\n    return (100 * number).toFixed(digits) + '%';\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/index.ts?");

/***/ }),

/***/ "./app/utils/loadSaveSlot.ts":
/*!***********************************!*\
  !*** ./app/utils/loadSaveSlot.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loadSaveSlot\": () => (/* binding */ loadSaveSlot)\n/* harmony export */ });\n/* harmony import */ var app_avatar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/avatar */ \"./app/avatar.ts\");\n/* harmony import */ var app_gems__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gems */ \"./app/gems.ts\");\n/* harmony import */ var app_utils_skills__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/skills */ \"./app/utils/skills.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n/* harmony import */ var app_utils_refreshActiveTiles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/refreshActiveTiles */ \"./app/utils/refreshActiveTiles.ts\");\n/* harmony import */ var app_utils_treasureMap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/treasureMap */ \"./app/utils/treasureMap.ts\");\n\n\n\n\n\n\n\nfunction loadSaveSlot(state, saveSlotIndex) {\n    state.saveSlotIndex = saveSlotIndex;\n    state.saved = (0,app_saveGame__WEBPACK_IMPORTED_MODULE_3__.fixSavedData)(state.saveSlots[saveSlotIndex]);\n    state.world.levelSums = [];\n    state.world.allTiles = {};\n    for (const tile of state.saved.world.tiles) {\n        const key = `${tile.x}x${tile.y}`;\n        state.world.allTiles[key] = (0,app_utils_refreshActiveTiles__WEBPACK_IMPORTED_MODULE_5__.initializeWorldMapTile)(state, {\n            ...tile,\n            centerX: 0,\n            centerY: 0,\n            target: { x: 0, y: 0, w: 0, h: 0 },\n            guards: 0,\n            journeyDistance: 0,\n            journeyPowerLevel: 0,\n            lootMarkers: [],\n        });\n    }\n    state.world.savedTiles = state.world.allTiles;\n    state.avatar.usedSkillPoints = 0;\n    state.avatar.affinityBonuses = {\n        health: 0,\n        attack: 0,\n        defense: 0,\n        money: 0,\n    };\n    for (const skill of app_utils_skills__WEBPACK_IMPORTED_MODULE_2__.skills) {\n        const level = (0,app_utils_skills__WEBPACK_IMPORTED_MODULE_2__.getSkillLevel)(state, skill.key);\n        const pointsUsed = (level * (level + 1)) / 2;\n        state.avatar.usedSkillPoints += pointsUsed;\n        state.avatar.affinityBonuses[skill.affinity] += pointsUsed;\n    }\n    (0,app_utils_treasureMap__WEBPACK_IMPORTED_MODULE_6__.initializeTreasureMapStateFromSave)(state);\n    (0,app_avatar__WEBPACK_IMPORTED_MODULE_0__.updatePlayerStats)(state);\n    delete state.world.currentGridCoords;\n    delete state.selectedTile;\n    state.goalCoordinates = [];\n    state.loot.hideStatsAt = state.time + 2000;\n    (0,app_state__WEBPACK_IMPORTED_MODULE_4__.pushScene)(state, 'map');\n    (0,app_gems__WEBPACK_IMPORTED_MODULE_1__.clearAllGems)(state);\n    (0,app_gems__WEBPACK_IMPORTED_MODULE_1__.checkToSpawnGems)(state);\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/loadSaveSlot.ts?");

/***/ }),

/***/ "./app/utils/refreshActiveTiles.ts":
/*!*****************************************!*\
  !*** ./app/utils/refreshActiveTiles.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initializeWorldMapTile\": () => (/* binding */ initializeWorldMapTile),\n/* harmony export */   \"refreshActiveTiles\": () => (/* binding */ refreshActiveTiles)\n/* harmony export */ });\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_monsters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/monsters */ \"./app/monsters.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\n\nfunction refreshActiveTiles(state) {\n    if (!state.world.currentGridCoords) {\n        return;\n    }\n    if (state.dungeon.currentDungeon) {\n        return;\n    }\n    const oldActiveTiles = state.world.activeTiles;\n    const { currentGridCoords, allTiles } = state.world;\n    state.world.activeTiles = [];\n    state.world.selectableTiles = new Set();\n    state.world.activeMonsterMarkers = [];\n    state.loot.activePowerupMarkers = new Set();\n    const isJourneyMode = state.currentScene === 'journey' || state.currentScene === 'voyage';\n    for (let y = currentGridCoords[1] - 4; y <= currentGridCoords[1] + 4; y++) {\n        for (let x = currentGridCoords[0] - 4; x <= currentGridCoords[0] + 4; x++) {\n            const key = `${x}x${y}`;\n            let mapTile = allTiles[key];\n            if (!mapTile) {\n                mapTile = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_5__.getTileData)(state, [x, y], true);\n                mapTile.level = -1;\n                initializeWorldMapTile(state, mapTile);\n            }\n            if (x >= currentGridCoords[0] - 3 && x <= currentGridCoords[0] + 3\n                && y >= currentGridCoords[1] - 3 && y <= currentGridCoords[1] + 3) {\n                state.world.selectableTiles.add(mapTile);\n            }\n            state.world.activeTiles.push(mapTile);\n            if (mapTile.monsterMarker) {\n                state.world.activeMonsterMarkers.push(mapTile.monsterMarker);\n            }\n            for (const lootMarker of mapTile.lootMarkers) {\n                if (lootMarker.loot.type !== 'coins') {\n                    state.loot.activePowerupMarkers.add(lootMarker);\n                }\n            }\n            // If a tile becomes active with no loot and isn't exhausted, make it spawn loot.\n            if (!mapTile.exhaustedDuration && !mapTile.lootMarkers.length) {\n                (0,app_loot__WEBPACK_IMPORTED_MODULE_1__.checkToGenerateLootForTile)(state, mapTile);\n                if (!isJourneyMode) {\n                    (0,app_monsters__WEBPACK_IMPORTED_MODULE_2__.checkToGenerateMonster)(state, mapTile, 0.25);\n                }\n            }\n            if (isJourneyMode) {\n                // For simplicity, all journey tiles are considered exhausted to avoid generating new loot/monsters.\n                mapTile.exhaustedDuration = 100;\n            }\n        }\n    }\n    if (state.selectedTile && !state.world.selectableTiles.has(state.selectedTile)) {\n        delete state.selectedTile;\n    }\n    for (const mapTile of oldActiveTiles) {\n        if (state.world.activeTiles.indexOf(mapTile) < 0) {\n            delete mapTile.canvas;\n        }\n    }\n}\nfunction initializeWorldMapTile(state, mapTile) {\n    var _a;\n    const realCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_5__.toRealCoords)(state, [mapTile.x, mapTile.y]);\n    mapTile.centerX = realCoords[0] + app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength / 2;\n    mapTile.centerY = realCoords[1] + app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength / 2;\n    if (state.currentScene === 'journey' || state.currentScene === 'voyage') {\n        mapTile.journeyDistance = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_3__.getDistance)(state.world.journeyModeOrigin, realCoords);\n        const gridDistance = mapTile.journeyDistance / app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength;\n        const minPowerLevel = state.world.journeyModePower - 0.5 + gridDistance / 16;\n        const maxPowerLevel = state.world.journeyModePower + 0.5 + gridDistance / 12;\n        mapTile.journeyPowerLevel = app_utils_Random__WEBPACK_IMPORTED_MODULE_4__[\"default\"].range(minPowerLevel, maxPowerLevel);\n        // Calculation for journey mode tile level:\n        // First choose a range of desired levels based on the starting tile level and a desired range\n        // of tiles based on distance (so tiles will be more varied the further you travel).\n        // The bottom range is at least tile level - 1, and the top range is at most maxTileLevel.\n        // The variance can be as high as 4 resulting in 5 different tiles.\n        // Then the tiles power is converted to a % based on its relative power to the min and max possible values\n        // and that percentage is mapped linearly from the lowest to highest level tiles.\n        if (mapTile.journeyDistance < app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.emptyJourneyRadius) {\n            mapTile.level = state.world.journeyModeTileLevel;\n        }\n        else {\n            // Variance of 3 gives 4 distinct tile offsets: 0,1,2,3\n            const desiredVariance = Math.min(3, Math.ceil(gridDistance / 8));\n            // The chance for a tile with level below the base tile only exists at the start of each journey.\n            //const lowerTileOffset = gridDistance >= 10 ? 0 : 1;\n            const lowerTileOffset = Math.max(0, 1 - gridDistance / 10);\n            const maxLevel = Math.min(app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.maxTileLevel, state.world.journeyModeTileLevel - lowerTileOffset + desiredVariance);\n            const minLevel = Math.max(0, state.world.journeyModeTileLevel - 1, maxLevel - desiredVariance);\n            const powerPercent = (mapTile.journeyPowerLevel - minPowerLevel) / (maxPowerLevel - minPowerLevel);\n            mapTile.level = Math.round(minLevel + (maxLevel - minLevel) * powerPercent);\n            //console.log([minPowerLevel, maxPowerLevel], desiredVariance, [minLevel, maxLevel], powerPercent, mapTile.level);\n            //console.log(mapTile);\n        }\n    }\n    else {\n        // Level sums are only calculated for map mode tiles.\n        for (let i = 0; i <= mapTile.level; i++) {\n            state.world.levelSums[i] = ((_a = state.world.levelSums[i]) !== null && _a !== void 0 ? _a : 0) + (1 + mapTile.level - i);\n        }\n    }\n    delete mapTile.canvas;\n    if (!mapTile.lootMarkers) {\n        mapTile.lootMarkers = [];\n    }\n    mapTile.neighbors = [];\n    for (let y = -1; y <= 1; y++) {\n        for (let x = -1; x <= 1; x++) {\n            const i = 3 * (y + 1) + (x + 1);\n            if (x === 0 && y === 0) {\n                mapTile.neighbors[i] = mapTile;\n                continue;\n            }\n            const otherTile = state.world.allTiles[`${mapTile.x + x}x${mapTile.y + y}`];\n            if (!otherTile)\n                continue;\n            // Delete the other tile canvas in case it needs to be updated.\n            // In the normal scene this only really applies to ocean tiles since all newly\n            // explored tiles are shallow water, but in journey mode this can apply to\n            // anything.\n            delete otherTile.canvas;\n            mapTile.neighbors[i] = otherTile;\n            if (otherTile.neighbors) {\n                otherTile.neighbors[8 - i] = mapTile;\n            }\n        }\n    }\n    state.world.allTiles[`${mapTile.x}x${mapTile.y}`] = mapTile;\n    return mapTile;\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/refreshActiveTiles.ts?");

/***/ }),

/***/ "./app/utils/skills.ts":
/*!*****************************!*\
  !*** ./app/utils/skills.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"canAffordSkill\": () => (/* binding */ canAffordSkill),\n/* harmony export */   \"canLearnSkill\": () => (/* binding */ canLearnSkill),\n/* harmony export */   \"getAttackSkillBonus\": () => (/* binding */ getAttackSkillBonus),\n/* harmony export */   \"getAvailableSkillPoints\": () => (/* binding */ getAvailableSkillPoints),\n/* harmony export */   \"getDefenseSkillBonus\": () => (/* binding */ getDefenseSkillBonus),\n/* harmony export */   \"getHealthSkillBonus\": () => (/* binding */ getHealthSkillBonus),\n/* harmony export */   \"getMoneySkillBonus\": () => (/* binding */ getMoneySkillBonus),\n/* harmony export */   \"getSkillCost\": () => (/* binding */ getSkillCost),\n/* harmony export */   \"getSkillLevel\": () => (/* binding */ getSkillLevel),\n/* harmony export */   \"getSkillValue\": () => (/* binding */ getSkillValue),\n/* harmony export */   \"getTotalSkillPoints\": () => (/* binding */ getTotalSkillPoints),\n/* harmony export */   \"skills\": () => (/* binding */ skills)\n/* harmony export */ });\n/* harmony import */ var app_images__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/images */ \"./app/images.ts\");\n\nconst skills = [\n    // Health Skills\n    {\n        key: 'regeneration',\n        affinity: 'health',\n        name: 'Regeneration', description: '% increased health regeneration.',\n        value: 0.2, type: '*',\n        x: 0, y: -1,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.clockSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.heartSource,\n    },\n    {\n        key: 'healthPower',\n        requires: 'regeneration',\n        affinity: 'health',\n        name: 'Vitality', description: '% increased value of health power ups.',\n        value: 0.1, type: '*',\n        x: 0, y: -2,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.heartSource,\n    },\n    {\n        key: 'healthOffense',\n        requires: 'healthPower',\n        affinity: 'health',\n        name: 'Full Power', description: '# attack per 100 current health.',\n        value: 2, type: '+',\n        x: -1, y: -2,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.heartSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.swordSource,\n    },\n    {\n        key: 'healthDefense',\n        requires: 'healthPower',\n        affinity: 'health',\n        name: 'Caution', description: '# defense per 100 missing health.',\n        value: 4, type: '+',\n        x: 1, y: -2,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.heartSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.shieldSource,\n    },\n    // Attack skills\n    {\n        key: 'attackSpeed',\n        affinity: 'attack',\n        name: 'Ferocity', description: '% increased attack speed.',\n        value: 0.1, type: '*',\n        x: -1, y: 0,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.shoeSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.swordSource,\n    },\n    {\n        key: 'attackPower',\n        requires: 'attackSpeed',\n        affinity: 'attack',\n        name: 'Strength', description: '% increased value of attack power ups.',\n        value: 0.1, type: '*',\n        x: -2, y: 0,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.swordSource,\n    },\n    {\n        key: 'attackOffense',\n        requires: 'attackPower',\n        affinity: 'attack',\n        name: 'Shredder', description: 'Permanently reduce enemy defense by % of your attack on each attack.',\n        value: 0.02, type: '+',\n        x: -2, y: -1,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.swordSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.crabSource,\n    },\n    {\n        key: 'attackDefense',\n        requires: 'attackPower',\n        affinity: 'attack',\n        name: 'Vampiric Strike', description: '% of damage is gained as health.',\n        value: 0.02, type: '+',\n        x: -2, y: 1,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.swordSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.heartSource,\n    },\n    // Defense skills\n    {\n        key: 'dodge',\n        affinity: 'defense',\n        name: 'Acrobat', description: '% chance to dodge attacks.',\n        value: 0.05, type: '/',\n        x: 1, y: 0,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.shoeSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.shieldSource,\n    },\n    {\n        key: 'defensePower',\n        requires: 'dodge',\n        affinity: 'defense',\n        name: 'Toughness', description: '% increased value of defense power ups.',\n        value: 0.1, type: '*',\n        x: 2, y: 0,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.shieldSource,\n    },\n    {\n        key: 'defenseOffense',\n        requires: 'defensePower',\n        affinity: 'defense',\n        name: 'Urchin', description: 'Attackers take % of damage blocked as damage.',\n        value: 0.5, type: '+',\n        x: 2, y: -1,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.shieldSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.crabSource,\n    },\n    {\n        key: 'defenseDefense',\n        requires: 'defensePower',\n        affinity: 'defense',\n        name: 'Iron Shell', description: 'Permanently reduce enemy attack by % of your defense on each block.',\n        value: 0.02, type: '+',\n        x: 2, y: 1,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.shieldSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.turtleSource,\n    },\n    // Utility skills\n    {\n        key: 'radius',\n        affinity: 'money',\n        name: 'Adventurer', description: '% increased collection area.',\n        value: 0.1, type: '*',\n        x: 0, y: 1,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.shoeSource,\n    },\n    {\n        key: 'experiencePower',\n        requires: 'radius',\n        affinity: 'money',\n        name: 'Wisdom', description: '% increased experience gained.',\n        value: 0.1, type: '*',\n        x: 0, y: 2,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.scrollSource,\n    },\n    {\n        key: 'explorer',\n        requires: 'experiencePower',\n        affinity: 'money',\n        name: 'Explorer', description: '% reduced cost to upgrade islands.',\n        value: 0.1, type: '/',\n        x: -1, y: 2,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.shoeSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.outlinedMoneySource\n    },\n    {\n        key: 'conquerer',\n        requires: 'experiencePower',\n        affinity: 'money',\n        name: 'Conquerer', description: '% reduced power of discovered monsters.',\n        value: 0.1, type: '/',\n        x: 1, y: 2,\n        source: app_images__WEBPACK_IMPORTED_MODULE_0__.shoeSource, secondSource: app_images__WEBPACK_IMPORTED_MODULE_0__.outlinedMoneySource\n    },\n];\nconst skillsByKey = {};\nfor (const skill of skills) {\n    skillsByKey[skill.key] = skill;\n}\nfunction getSkillLevel(state, key) {\n    var _a;\n    return (_a = state.saved.avatar.skillLevels[key]) !== null && _a !== void 0 ? _a : 0;\n}\nfunction getTotalSkillPoints(state) {\n    return (state.saved.avatar.level - 1)\n        + state.saved.world.journeySkillPoints\n        + (state.saved.world.dungeonLevelCap / 2 - 1);\n}\nfunction getAvailableSkillPoints(state) {\n    return getTotalSkillPoints(state) - state.avatar.usedSkillPoints;\n}\nfunction canLearnSkill(state, skill) {\n    if (!skill.requires)\n        return true;\n    // If this skill requires another skill, we can only learn it if its current level\n    // is less than the level of the skill it requres.\n    return getSkillLevel(state, skill.key) < getSkillLevel(state, skill.requires);\n}\nfunction canAffordSkill(state, skill) {\n    return getAvailableSkillPoints(state) >= getSkillCost(state, skill);\n}\nfunction getSkillCost(state, skill) {\n    return getSkillLevel(state, skill.key) + 1;\n}\nfunction getSkillValue(state, skillKey, level) {\n    const skill = skillsByKey[skillKey];\n    level = level !== null && level !== void 0 ? level : getSkillLevel(state, skillKey);\n    if (level === 0)\n        return 0;\n    if (skill.type === '+')\n        return level * skill.value;\n    if (skill.type === '*')\n        return Math.pow(1 + skill.value, level) - 1;\n    if (skill.type === '/')\n        return 1 - Math.pow(1 - skill.value, level);\n    throw new Error('Unknown skill type: ' + skill.type);\n}\n// An unspent skill point gives you 1% to all stats.\n// A spent skill point gives you 2% to that stat, 1% to adjacent stats, and 0% to polar stat.\nfunction getHealthSkillBonus(state) {\n    const { affinityBonuses } = state.avatar;\n    return 1 + (affinityBonuses.health * 2 + affinityBonuses.attack + affinityBonuses.defense + getAvailableSkillPoints(state)) / 100;\n}\nfunction getAttackSkillBonus(state) {\n    const { affinityBonuses } = state.avatar;\n    return 1 + (affinityBonuses.attack * 2 + affinityBonuses.health + affinityBonuses.money + getAvailableSkillPoints(state)) / 100;\n}\nfunction getDefenseSkillBonus(state) {\n    const { affinityBonuses } = state.avatar;\n    return 1 + (affinityBonuses.defense * 2 + affinityBonuses.health + affinityBonuses.money + getAvailableSkillPoints(state)) / 100;\n}\nfunction getMoneySkillBonus(state) {\n    const { affinityBonuses } = state.avatar;\n    return 1 + (affinityBonuses.money * 2 + affinityBonuses.attack + affinityBonuses.defense + getAvailableSkillPoints(state)) / 100;\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/skills.ts?");

/***/ }),

/***/ "./app/utils/treasureMap.ts":
/*!**********************************!*\
  !*** ./app/utils/treasureMap.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getTreasureLocation\": () => (/* binding */ getTreasureLocation),\n/* harmony export */   \"initializeTreasureMapStateFromSave\": () => (/* binding */ initializeTreasureMapStateFromSave)\n/* harmony export */ });\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n\n\nfunction getTreasureLocation(savedMap) {\n    const random = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_1__[\"default\"].seed(savedMap.seed);\n    return [\n        random.range(0, savedMap.size - 1),\n        random.nextSeed().range(0, savedMap.size - 1),\n    ];\n}\nfunction makeMap(size) {\n    const map = {\n        tiles: [],\n        revealAnimationTime: 0,\n    };\n    for (let y = 0; y < size; y++) {\n        map.tiles[y] = [];\n        for (let x = 0; x < size; x++) {\n            map.tiles[y][x] = {};\n        }\n    }\n    return map;\n}\nfunction initializeTreasureMapStateFromSave(state) {\n    const savedMap = state.saved.treasureHunt.currentMap;\n    if (!savedMap) {\n        delete state.treasureHunt.currentMap;\n        return;\n    }\n    const [tx, ty] = getTreasureLocation(savedMap);\n    const currentMap = makeMap(savedMap.size);\n    if (savedMap.revealedCoordinates.length) {\n        for (const [x, y] of savedMap.revealedCoordinates) {\n            currentMap.tiles[y][x].isRevealed = true;\n            // In case something changes in our generator and the dungeon is newly uncovered on load\n            // make sure to set the dungeonLevel, which indicates the dungeon has been found.\n            if (x === tx && y === ty && !savedMap.dungeonLevel) {\n                savedMap.dungeonLevel = (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_0__.getDungeonLevel)(state, state.saved.avatar.level);\n            }\n        }\n    }\n    state.treasureHunt.currentMap = currentMap;\n    if (savedMap.dungeonLevel) {\n        currentMap.dungeon = (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_0__.createDungeon)(state, savedMap.dungeonLevel);\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/treasureMap.ts?");

/***/ }),

/***/ "./app/utils/updateGems.ts":
/*!*********************************!*\
  !*** ./app/utils/updateGems.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"updateGems\": () => (/* binding */ updateGems)\n/* harmony export */ });\n/* harmony import */ var app_advanceGameState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/advanceGameState */ \"./app/advanceGameState.ts\");\n/* harmony import */ var app_gems__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/gems */ \"./app/gems.ts\");\n\n\nfunction updateGems(state) {\n    var _a;\n    for (const gem of app_gems__WEBPACK_IMPORTED_MODULE_1__.gemData) {\n        const currentTick = state.gems.colorCounters[gem.color] || 0;\n        if (!currentTick) {\n            continue;\n        }\n        if (state.loot.collectingLoot.length) {\n            state.gems.nextTickTime = state.time + gem.tickDuration;\n        }\n        if (state.gems.nextTickTime && state.time >= state.gems.nextTickTime) {\n            state.gems.colorCounters[gem.color] = currentTick - 1;\n            (0,app_advanceGameState__WEBPACK_IMPORTED_MODULE_0__.advanceGameState)(state);\n            state.gems.nextTickTime = state.time + gem.tickDuration;\n            for (const monsterMarker of state.world.activeMonsterMarkers) {\n                if (((_a = monsterMarker.monster.tint) === null || _a === void 0 ? void 0 : _a.color) !== gem.color) {\n                    monsterMarker.monster.tint = {\n                        color: gem.color,\n                        amount: 0,\n                    };\n                }\n                monsterMarker.monster.tint.amount += gem.tintAmount;\n                monsterMarker.monster.currentHealth = Math.max(1, Math.floor(monsterMarker.monster.currentHealth * gem.debuff));\n                monsterMarker.monster.attack = Math.max(1, Math.floor(monsterMarker.monster.attack * gem.debuff));\n                monsterMarker.monster.defense = Math.max(1, Math.floor(monsterMarker.monster.defense * gem.debuff));\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/updateGems.ts?");

/***/ }),

/***/ "./app/utils/world.ts":
/*!****************************!*\
  !*** ./app/utils/world.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"exhaustTile\": () => (/* binding */ exhaustTile),\n/* harmony export */   \"getActualScale\": () => (/* binding */ getActualScale),\n/* harmony export */   \"getGridOrigin\": () => (/* binding */ getGridOrigin),\n/* harmony export */   \"getGridRectangle\": () => (/* binding */ getGridRectangle),\n/* harmony export */   \"getIconSize\": () => (/* binding */ getIconSize),\n/* harmony export */   \"getOrigin\": () => (/* binding */ getOrigin),\n/* harmony export */   \"getTileData\": () => (/* binding */ getTileData),\n/* harmony export */   \"getTilePower\": () => (/* binding */ getTilePower),\n/* harmony export */   \"isTileExplored\": () => (/* binding */ isTileExplored),\n/* harmony export */   \"project\": () => (/* binding */ project),\n/* harmony export */   \"toGridCoords\": () => (/* binding */ toGridCoords),\n/* harmony export */   \"toRealCoords\": () => (/* binding */ toRealCoords),\n/* harmony export */   \"unproject\": () => (/* binding */ unproject)\n/* harmony export */ });\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/state */ \"./app/state.ts\");\n\n\nfunction isTileExplored(state, gridCoords) {\n    const key = `${gridCoords[0]}x${gridCoords[1]}`;\n    return !!state.world.allTiles[key];\n}\nfunction exhaustTile(tile) {\n    tile.exhaustedDuration = tile.level * 2 + 8;\n    tile.exhaustCounter = 0;\n}\nfunction getActualScale(state) {\n    const { canvas, iconSize } = state.display;\n    if (state.currentScene === 'journey' || state.currentScene === 'voyage') {\n        return app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.maxScale;\n    }\n    if (state.currentScene === 'treasureMap') {\n        const savedMap = state.saved.treasureHunt.currentMap;\n        return Math.min((canvas.height - 2 * iconSize) / (savedMap.size * app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength), (canvas.width - iconSize) / (savedMap.size * app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength));\n    }\n    if (state.dungeon.currentDungeon) {\n        return Math.min((canvas.height - 20) / (5 * app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength), (canvas.width - 20) / (5 * app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength));\n    }\n    // Math.round(gridLength * state.world.displayScale) / gridLength;\n    return state.world.displayScale;\n}\nfunction getGridRectangle(state, coords) {\n    const topLeft = project(state, toRealCoords(state, coords));\n    const bottomRight = project(state, toRealCoords(state, [coords[0] + 1, coords[1] + 1]));\n    return {\n        x: Math.ceil(topLeft[0]),\n        y: Math.ceil(topLeft[1]),\n        w: Math.ceil(bottomRight[0]) - Math.ceil(topLeft[0]),\n        h: Math.ceil(bottomRight[1]) - Math.ceil(topLeft[1]),\n    };\n}\nfunction getIconSize() {\n    const { canvas } = (0,app_state__WEBPACK_IMPORTED_MODULE_1__.getState)().display;\n    return 16 * Math.floor(Math.min(canvas.width / 6, canvas.height / 6) / 16);\n}\n// Returns the global coordinates of the top left corner of the tile with coordinates [0, 0].\nfunction getGridOrigin(state) {\n    if (state.currentScene === 'journey' || state.currentScene === 'voyage') {\n        return state.world.journeyModeOrigin;\n    }\n    return [0, 0];\n}\n// Returns the global coordinates of the origin, which is mapped to the center of the canvas.\nfunction getOrigin(state) {\n    var _a;\n    if (state.currentScene === 'treasureMap') {\n        const savedMap = state.saved.treasureHunt.currentMap;\n        return [app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength * (savedMap.size) / 2, app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength * (savedMap.size - 1) / 2];\n    }\n    return state.dungeon.currentDungeon\n        // The origin is always the middle of the center square.\n        ? [app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength * 2.5, app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength * 2.5]\n        : ((_a = state.world.origin) !== null && _a !== void 0 ? _a : [0, 0]);\n}\nfunction project(state, coords) {\n    const { canvas } = state.display;\n    const origin = getOrigin(state);\n    const scaleToUse = getActualScale(state);\n    const x = Math.round((coords[0] - origin[0]) * scaleToUse) + Math.round(canvas.width / 2);\n    const y = Math.round((coords[1] - origin[1]) * scaleToUse) + Math.round(canvas.height / 2);\n    return [x, y];\n}\nfunction unproject(state, screenCoords) {\n    const { canvas } = state.display;\n    const origin = getOrigin(state);\n    const scaleToUse = getActualScale(state);\n    const longitude = (screenCoords[0] - canvas.width / 2) / scaleToUse + origin[0];\n    const lat = (screenCoords[1] - canvas.height / 2) / scaleToUse + origin[1];\n    return [longitude, lat];\n}\nfunction toGridCoords(state, realCoords) {\n    const gridOrigin = getGridOrigin(state);\n    return [\n        Math.floor((realCoords[0] - gridOrigin[0]) / app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength),\n        Math.floor((realCoords[1] - gridOrigin[1]) / app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength),\n    ];\n}\nfunction toRealCoords(state, gridCoords) {\n    const gridOrigin = getGridOrigin(state);\n    return [\n        gridCoords[0] * app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength + gridOrigin[0],\n        gridCoords[1] * app_gameConstants__WEBPACK_IMPORTED_MODULE_0__.gridLength + gridOrigin[1],\n    ];\n}\nfunction getTileData(state, gridCoords, returnDefault = false) {\n    const key = `${gridCoords[0]}x${gridCoords[1]}`;\n    const mapTile = state.world.allTiles[key];\n    return mapTile !== null && mapTile !== void 0 ? mapTile : (returnDefault ? { level: -1, x: gridCoords[0], y: gridCoords[1] } : null);\n}\nfunction getTilePower(state, tile) {\n    var _a, _b, _c, _d, _e;\n    // In journey/voyage modes, each tile is just assigned a specific power on creation.\n    if (state.currentScene === 'journey' || state.currentScene === 'voyage') {\n        return tile.journeyPowerLevel;\n    }\n    // In the normal map scene, the power of tiles depends on how many tiles have been upgraded\n    // as well as the level of the tile and its neighbors.\n    if (!tile.neighbors) {\n        console.error(tile);\n        throw new Error('Expected tile.neighbors to be defined');\n    }\n    // Base power is 1 + 5% of total tiles leveled + 25% of current tile level.\n    let power = 1 + ((_a = state.world.levelSums[1]) !== null && _a !== void 0 ? _a : 0) / 20 + tile.level / 4;\n    // Tile gains 10% of each of its neighbors level.\n    for (const sideKey of [1, 3, 5, 7]) {\n        power += ((_c = (_b = tile.neighbors[sideKey]) === null || _b === void 0 ? void 0 : _b.level) !== null && _c !== void 0 ? _c : 0) / 10;\n    }\n    // Tile gains 5% of each of its corner neighbors level.\n    for (const cornerKey of [0, 2, 6, 8]) {\n        power += ((_e = (_d = tile.neighbors[cornerKey]) === null || _d === void 0 ? void 0 : _d.level) !== null && _e !== void 0 ? _e : 0) / 20;\n    }\n    return power;\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/utils/world.ts?");

/***/ }),

/***/ "./app/world.ts":
/*!**********************!*\
  !*** ./app/world.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"setCurrentPosition\": () => (/* binding */ setCurrentPosition)\n/* harmony export */ });\n/* harmony import */ var app_advanceGameState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/advanceGameState */ \"./app/advanceGameState.ts\");\n/* harmony import */ var app_fastMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/fastMode */ \"./app/fastMode.ts\");\n/* harmony import */ var app_gameConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/gameConstants */ \"./app/gameConstants.ts\");\n/* harmony import */ var app_gems__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/gems */ \"./app/gems.ts\");\n/* harmony import */ var app_monsters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/monsters */ \"./app/monsters.ts\");\n/* harmony import */ var app_saveGame__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/saveGame */ \"./app/saveGame.ts\");\n/* harmony import */ var app_utils_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/index */ \"./app/utils/index.ts\");\n/* harmony import */ var app_utils_refreshActiveTiles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/refreshActiveTiles */ \"./app/utils/refreshActiveTiles.ts\");\n/* harmony import */ var app_utils_world__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/world */ \"./app/utils/world.ts\");\n\n\n\n\n\n\n\n\n\nfunction setCurrentPosition(state, realCoords) {\n    state.world.currentPosition = realCoords;\n    // Only apply updates for moving if we have selected and loaded saved game.\n    if (state.currentScene === 'loading' || state.currentScene === 'title') {\n        return;\n    }\n    if (!state.goalCoordinates.length || state.globalPosition.isFixingGPS) {\n        state.goalCoordinates = [state.world.currentPosition];\n        state.lastGoalTime = state.time;\n    }\n    else if (state.lastGoalTime) {\n        let shouldAddPoint = true;\n        for (const recentPoint of state.goalCoordinates) {\n            const distance = (0,app_utils_index__WEBPACK_IMPORTED_MODULE_6__.getDistance)(state.world.currentPosition, recentPoint);\n            if (distance >= app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength / 2) {\n                // Reset goal coordinates to only include the current position.\n                state.goalCoordinates = [state.world.currentPosition];\n                // Check if we need to move towards enabling fast mode in case the player\n                // is moving too quickly.\n                (0,app_fastMode__WEBPACK_IMPORTED_MODULE_1__.updateFastMode)(state, state.time - state.lastGoalTime);\n                state.lastGoalTime = state.time;\n                (0,app_advanceGameState__WEBPACK_IMPORTED_MODULE_0__.advanceGameState)(state);\n            }\n            else if (distance < app_gameConstants__WEBPACK_IMPORTED_MODULE_2__.gridLength / 20) {\n                // We don't want to add too many points to check, so only add this new point if it is\n                // least 1 / 10 of the required goal distance.\n                shouldAddPoint = false;\n                break;\n            }\n        }\n        if (shouldAddPoint) {\n            state.goalCoordinates.push(state.world.currentPosition);\n        }\n    }\n    if (state.globalPosition.isFastMode && state.time > state.globalPosition.endFastModeTime) {\n        state.globalPosition.isFastMode = state.globalPosition.isStartingFastMode = false;\n        (0,app_gems__WEBPACK_IMPORTED_MODULE_3__.checkToSpawnGems)(state);\n    }\n    if (state.globalPosition.isFixingGPS && state.time > state.globalPosition.endFixingGPSTime) {\n        state.globalPosition.isFixingGPS = false;\n        if (state.world.currentGridCoords) {\n            exploreSurroundingTiles(state);\n        }\n        (0,app_gems__WEBPACK_IMPORTED_MODULE_3__.checkToSpawnGems)(state);\n    }\n    const { currentGridCoords } = state.world;\n    const newGridCoords = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_8__.toGridCoords)(state, realCoords);\n    if ((currentGridCoords === null || currentGridCoords === void 0 ? void 0 : currentGridCoords[0]) === newGridCoords[0] && (currentGridCoords === null || currentGridCoords === void 0 ? void 0 : currentGridCoords[1]) === newGridCoords[1]) {\n        // If your coords haven't changed and this location is already explored, do nothing,\n        // but if the location isn't explored yet (say fixing gps was on previously), then DO\n        // allow exploring this tile.\n        // getTileData returns null if the second parameter is false and the tile is unexplored.\n        const mapTile = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_8__.getTileData)(state, currentGridCoords, false);\n        if (mapTile && mapTile.level >= 0) {\n            return;\n        }\n    }\n    state.world.currentGridCoords = newGridCoords;\n    if (!state.globalPosition.isFixingGPS) {\n        exploreSurroundingTiles(state);\n    }\n    (0,app_utils_refreshActiveTiles__WEBPACK_IMPORTED_MODULE_7__.refreshActiveTiles)(state);\n}\nfunction exploreSurroundingTiles(state) {\n    if (!state.world.currentGridCoords) {\n        return;\n    }\n    let newTileFound = false;\n    for (let dy = -1; dy <= 1; dy++) {\n        for (let dx = -1; dx <= 1; dx++) {\n            const mapTile = (0,app_utils_world__WEBPACK_IMPORTED_MODULE_8__.getTileData)(state, [state.world.currentGridCoords[0] + dx, state.world.currentGridCoords[1] + dy], true);\n            if (mapTile.level < 0) {\n                mapTile.level = 0;\n                (0,app_utils_refreshActiveTiles__WEBPACK_IMPORTED_MODULE_7__.initializeWorldMapTile)(state, mapTile);\n                newTileFound = true;\n            }\n            if (!mapTile.isExplored) {\n                mapTile.isExplored = true;\n                if (state.currentScene === 'journey') {\n                    (0,app_monsters__WEBPACK_IMPORTED_MODULE_4__.checkToGenerateMonster)(state, mapTile, 1 / 6);\n                }\n            }\n        }\n    }\n    if (newTileFound) {\n        (0,app_saveGame__WEBPACK_IMPORTED_MODULE_5__.saveGame)(state);\n        (0,app_utils_refreshActiveTiles__WEBPACK_IMPORTED_MODULE_7__.refreshActiveTiles)(state);\n    }\n}\n\n\n//# sourceURL=webpack://geocrasher/./app/world.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/client.ts");
/******/ 	
/******/ })()
;